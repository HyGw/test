/** \file vpp_api.c
 * vpp_api.c
 *
 *  This file contains the implementation of VPP part of the VP-API
 *
 * Copyright (c) 2005, Legerity Inc.
 * All rights reserved
 *
 * This software is the property of Legerity , Inc. Please refer to the
 * Non Disclosure Agreement (NDA) that you have signed for more information
 * on legal obligations in using, modifying or distributing this file.
 */

/* INCLUDES */
#include "vp_api.h"

#if defined (VP_CC_VPP_SERIES)  /* Compile Further only if required */

#include "vpp_api.h"
#include "vp_api_int.h"
#include "boot_common.h"
#include "vpp_hbi.h"

/******************************************************************************
 *                        VPP SPECIFIC DEFINES                                *
 ******************************************************************************/

/* This macro returns the profile length of a profile generated by profile
 * wizard
 */
#define GET_PROFILE_LEN(prfPtr) (prfPtr[3])

/* This macro returns the profile type of a profile generated by profile wizard
 * Note that the profile type generated by Profile wizard matches that of VPP
 * except for Device and Ring cadence profile;
 */
#define GET_PROFILE_TYPE(prfPtr) ((prfPtr[1]) & (0x3f))

/* Used to obtain the length of cadence profile */
#define GET_CAD_PROFILE_LEN(prfPtr) (prfPtr[7])

/* #define GET_CID_VPP_PROFILE_TYPE(prfPtr) ((prfPtr[1]) & (0x3f)) */

/* Default data for profiles */
#define VPP_DEFAULT_RING_ON_CAD_PRF     0x00, 0x08, 0x00, 0x06, 0x00, 0x00, \
    0x00, 0x02, 0x01, 0x07 /* Ringing state command */
#define VPP_DEFAULT_RING_PRF            0x00, 0x04, 0x00, 0x10, 0x00, 0x0D, \
    0xD2, 0x00, 0x00, 0x01, 0x01, 0x5B, 0x4C, 0x20, 0x00, 0x00, 0x00, 0x68, \
    0x04, 0x00 /* Sine, 20 Hz, 1.41 CF, 50.00 Vpk, 0.00 Bias */

/* VPP specific API function prototypes */
static VpStatusType
VppInitDevice(
    VpDevCtxType *pDevCtx,
    VpProfilePtrType pDevProfile,
    VpProfilePtrType pAcProfile,
    VpProfilePtrType pDcProfile,
    VpProfilePtrType pRingProfile,
    VpProfilePtrType pFxoAcProfile,
    VpProfilePtrType pFxoCfgProfile);

static VpStatusType
VppConfigLine(
    VpLineCtxType *pLineCtx,
    VpProfilePtrType pAcProfile,
    VpProfilePtrType pDcProfile,
    VpProfilePtrType pRingProfile);

static VpStatusType
VppInitRing(
    VpLineCtxType *pLineCtx,
    VpProfilePtrType pCadProfile,
    VpProfilePtrType pCidProfile);

static VpStatusType
VppInitProfile(
    VpDevCtxType *pDevCtx,
    VpProfileType type,
    VpProfilePtrType pProfileIndex,
    VpProfilePtrType pProfile);

static VpStatusType
VppSetLineState(
    VpLineCtxType *pLineCtx,
    VpLineStateType state);

static VpStatusType
VppSetLineTone(
    VpLineCtxType *pLineCtx,
    VpProfilePtrType pToneProfile,
    VpProfilePtrType pCadProfile,
    VpDtmfToneGenType *pDtmfControl);

static VpStatusType
VppSetOption(
    VpLineCtxType *pLineCtx,
    VpDevCtxType *pDevCtx,
    VpOptionIdType option,
    void *value);

static bool
VppGetEvent(
    VpDevCtxType *pDevCtx,
    VpEventType *pEvent);

static VpStatusType
VppGetResults(
    VpEventType *pEvent,
    void *pResults);

static VpStatusType
VppGetLoopCond(
    VpLineCtxType *pLineCtx,
    uint16 handle);

static VpStatusType
VppControlVoiceStream(
    VpLineCtxType *pLineCtx,
    uint8 streamId,
    VpVSConfControlType streamControl,/* Start, Stop the conference */
    VpVSConfModeType confMode);       /* Conference mode */

static VpStatusType
VppReadUpStreamPacket(
    VpLineCtxType *pLineCtx,
    VpPktDataPtrType pPacketData,
    uint8 streamId);

static VpStatusType
VppWriteDownStreamPacket(
    VpLineCtxType *pLineCtx,
    VpPktDataPtrType pPacketData,
    uint8 streamId);

static VpStatusType VppGetTimeStamp(
    VpDevCtxType *pDevCtx,
    uint16 *pTimeStamp);

static VpStatusType
VppReadPacketStatistics(
    VpLineCtxType *pLineCtx,
    uint16 handle);

/* VPP specific helper functions */
static bool
GenerateMailBoxProfile(
    uint8 channelId,
    VpProfileType type,
    VpProfilePtrType pProfile,
    uint16 *pCmdBuffer,
    uint8 *offset,
    VpDevCtxType *pDevCtx);

static bool
ComposeRingAndCadenceProfile(
    uint8 channelId,
    VpProfilePtrType pRingPrf,
    VpProfilePtrType pRingCadPrf,
    uint16 *pCmdBuffer,
    uint8 *offset);

static void
ConvertAndAppendPrfData(
    const VpProfilePtrType pSrcPrf,
    const uint8 length,
    uint16 *destPrfPtr,
    uint8 *offset);

static uint8
GetProfileTableMaxCount(
    const VpProfileType profileType);

static VppProfileType
ConvertApiPrfType2VppType(
    const VpProfileType type);

static bool
IsItValidProfile(
    const VpProfilePtrType pProfile,
    const VpProfileType type);

static VppLineStateType
ConvertApiState2VppState(
    const VpLineStateType state);

static VpStatusType
GenerateReponseMailBoxEvents(
    VpDevCtxType *pDevCtx,
    VpEventType *pEvent);

static VpStatusType
ReadVersionInfo(
    VpDeviceIdType deviceId,
    VpChkSumType *pResults);

static VpStatusType
ReadLineCond(
    VpDeviceIdType deviceId,
    VpLoopCondResultsType *pResults);

static VpStatusType
ReadPktStatistics(
    VpDeviceIdType deviceId,
    VpPacketStatisticsType *pResults);

static VpStatusType
AcquireMailBox(
    const VpDeviceIdType deviceId,
    const VppHbiPageId pageMailBox);

static VpStatusType
ReleaseMailBox(
    const VpDeviceIdType deviceId,
    const VppHbiPageId pageMailBox);

static VpStatusType
IssueHbiCommandNoCritical(
    const VpDeviceIdType deviceId,
    uint16 *cmdBuf,
    const uint16 length);

static VpStatusType
IssueHbiCommand(
    const VpDeviceIdType deviceId,
    uint16 *cmdBuf,
    const uint16 length);

static VpStatusType
ReadResponseMb(
    VpDeviceIdType deviceId,
    uint8 length,
    uint16 *pDataBuf);

static void
SetDefaultMasks(
    VpDeviceIdType deviceId);

static VpStatusType
ReadWritePackets(
    VpDeviceIdType deviceId,
    bool readFlag,
    VpPktDataPtrType pPacketData,
    uint8 mailBox);

static void
ExitOnHbiError(
    char *data);


/******************************************************************************
 *                   VPP Specific System Configuration Functions              *
 ******************************************************************************/
/**
 * VpMakeVppDeviceObject()
 * This function initializes the device context and device object to handle
 * VPP functionality.
 *
 * Preconditions:
 * The passed device object and device context pointers must be valid. The
 * device object pointer type should be for VPP device object type. Passed
 * context/objects are assumed to be un-initialized.
 *
 * Postconditions:
 * Initializes device context and device object based on input parameters and to
 * be able to handle VPP functionality.
 */
VpStatusType
VpMakeVppDeviceObject(
    VpDevCtxType *pDevCtx,           /**< Device Context to be initialized */
    VpVppDeviceObjectType *pDevObj)  /**< Device Object to be pointed to by
                                      * device context */
{
    int i;

    /* Initialize device Object */
    pDevObj->maxChannels = VPP_MAX_NUM_LINES;

    /* Initialize other elements in the device object */
    for(i = 0; i < VPP_RING_PROF_MAX_CNT; i++){
        pDevObj->pRingingProfileTable[i] = VP_NULL;
    }
    for(i = 0; i < VPP_RINGCAD_PROF_MAX_CNT; i++){
        pDevObj->pRingingCadProfileTable[i] = VP_NULL;
    }

    /* Initialize other elements in the device object */
    pDevObj->deviceInitOngoing = pDevObj->bootCompleteProcssing = FALSE;

    if (pDevCtx != VP_NULL) {
        return VpMakeVppDeviceCtx(pDevCtx, pDevObj);
    } else {
        return VP_STATUS_SUCCESS;
    }
} /* VpMakeVppDeviceObject() */


/**
 * VpMakeVppDeviceCtx()
 * This function initializes the device context to handle VPP functionality.
 *
 * Preconditions:
 * This function should be called after initializing the device object. This
 * function can be called more than once without modifying the contents of the
 * device object.
 *
 * Postconditions:
 * Initializes device context to be able to handle VPP functionality.
 */
VpStatusType
VpMakeVppDeviceCtx(
    VpDevCtxType *pDevCtx,           /**< Device Context to be initialized */
    VpVppDeviceObjectType *pDevObj)  /**< Device Object that has been already
                                      * initialized */
{
    if((pDevCtx == VP_NULL) || (pDevObj == VP_NULL)){
        return VP_STATUS_INVALID_ARG;
    }

    /* Initialize Device context */
    pDevCtx->pDevObj = pDevObj;
    pDevCtx->deviceType = VP_DEV_VPP_SERIES;

    /* Initialize the function pointers (for those functions that VPP
     * supports)
     */
    pDevCtx->funPtrsToApiFuncs.BootLoad = BootLoadImage;
    pDevCtx->funPtrsToApiFuncs.InitDevice = VppInitDevice;
    /* pDevCtx->funPtrsToApiFuncs.InitLine = VppInitLine; DevNotes: Change
     * this file after function has been changed */
    pDevCtx->funPtrsToApiFuncs.ConfigLine = VppConfigLine;
    pDevCtx->funPtrsToApiFuncs.InitRing = VppInitRing;
    pDevCtx->funPtrsToApiFuncs.InitProfile = VppInitProfile;
    pDevCtx->funPtrsToApiFuncs.SetLineState = VppSetLineState;
    pDevCtx->funPtrsToApiFuncs.SetLineTone = VppSetLineTone;
    pDevCtx->funPtrsToApiFuncs.SetOption = VppSetOption;

    pDevCtx->funPtrsToApiFuncs.GetEvent = VppGetEvent;
    pDevCtx->funPtrsToApiFuncs.GetResults = VppGetResults;
    pDevCtx->funPtrsToApiFuncs.GetLoopCond = VppGetLoopCond;

    pDevCtx->funPtrsToApiFuncs.ReadUpStreamPacket = VppReadUpStreamPacket;
    pDevCtx->funPtrsToApiFuncs.WriteDownStreamPacket = VppWriteDownStreamPacket;
    pDevCtx->funPtrsToApiFuncs.GetTimeStamp = VppGetTimeStamp;
    pDevCtx->funPtrsToApiFuncs.ReadPacketStatistics = VppReadPacketStatistics;
    pDevCtx->funPtrsToApiFuncs.ControlVoiceStream = VppControlVoiceStream;

    return VP_STATUS_SUCCESS;
} /* VpMakeVppDeviceCtx() */

/*
 * VpMakeVppLineObject()
 * This function initializes a line context using the information that is
 * passed. This function is like a C++ constructor. It initializes the passed
 * line context and line object based on the paramters provided. The passed line
 * object type should match with the type of device object type. It also
 * establishes a link between the device context and the line context. This
 * function SHOULD NEVER be called outside the VP-API. This is an VP-API
 * internal function.
 *
 * Preconditions:
 * This function assumes device context has already been created and
 * initialized. This function should only be called after downloading the boot
 * image to the device when applicable.
 *
 * Postconditions:
 * This function initializes the line context/line object. Line related VP-API
 * functions can be called after calling this function.
 */
VpStatusType
VpMakeVppLineObject(
    VpTermType termType,
    uint8 channelId,
    VpLineCtxType *pLineCtx,
    VpVppLineObjectType *pLineObj,
    VpDevCtxType *pDevCtx)
{
    VpVppDeviceObjectType *pDevObj;
    VpStatusType retVal = VP_STATUS_SUCCESS;

    /* Basic error checking */
    pDevObj = pDevCtx->pDevObj;
    if(channelId >= pDevObj->maxChannels){
        return VP_STATUS_INVALID_ARG;
    }

    /* Make sure VPP supports the requested termination type */
    if (termType != VP_TERM_FXS_GENERIC) {
       return VP_STATUS_ERR_VTD_CODE;
    }

    /* Initialize the line context */
    pLineCtx->pLineObj = pLineObj;
    pLineCtx->pDevCtx = pDevCtx;

    /* Establish the link between device context to line context */
    pDevCtx->pLineCtx[channelId] = pLineCtx;

    /* Initialize any variables inside the Line Object */
    pLineObj->activeRingPrfIndex = pLineObj->activeRingCadPrfIndex = -1;

    /* Initialize Line context/object (remaining) parameters */
    pLineObj->channelId = channelId;
    pLineObj->termType = termType;

    return retVal;
}  /* VpMakeVppLineObject() */

/******************************************************************************
 *                   VPP Specific Initialization Functions                    *
 ******************************************************************************/
/*
 * VppInitDevice()
 * This function calibrates the device and initializes all lines on the device
 * with the AC, DC, and Ringing parameters passed. See VP-API reference guide
 * for more information.
 *
 * Preconditions:
 * This function should be called only after creating and initializing the
 * device context.
 *
 * Postconditions:
 * Device is calibrated and all lines associated with this device are initialized
 * with the AC, DC, and Ringing Paramaters passed (DC and Ringing apply to FXS
 * type lines only).
 */
static VpStatusType
VppInitDevice(
    VpDevCtxType *pDevCtx,          /**< Pointer to device context for the
                                     * device that will be initialized
                                     */
    VpProfilePtrType pDevProfile,   /**< Pointer to Device Profile */
    VpProfilePtrType pAcProfile,    /**< Pointer to AC Profile that is applied
                                     * to all FXS lines on this device
                                     */
    VpProfilePtrType pDcProfile,    /**< Pointer to DC Profile that is applied
                                     * to all FXS lines on this device
                                     */
    VpProfilePtrType pRingProfile,  /**< Pointer to Ringing Profile that is
                                     * applied to all FXS lines on this device
                                     */
    VpProfilePtrType pFxoAcProfile, /**< Pointer to AC Profile that is applied
                                     * to all FXO lines on this device
                                     */
    VpProfilePtrType pFxoCfgProfile)/**< Pointer to Config Profile that is
                                     * applied to all FXO lines on this device
                                     */
{
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;
    VpStatusType retVal = VP_STATUS_SUCCESS;
    uint16 data;

    /* Because the first word is reserved for length of all commands */
    uint8 offset = 1;

    #define MAX_RING_PROFILE_LEN    (VPP_MAX_NUM_LINES * (VPP_RING_PRF_LEN + \
                VPP_RINGCAD_PRF_LEN + VPP_SELECT_PRF_LEN))
    #define CMD_BUF_LEN_INITDEVICE  (1 + VPP_AC_PRF_LEN + VPP_SELECT_PRF_LEN + \
                VPP_DC_PRF_LEN +  VPP_SELECT_PRF_LEN + MAX_RING_PROFILE_LEN + \
                10) /* Some dummy */
    #if (CMD_BUF_LEN_INITDEVICE > VPP_CMD_PAGE_MAX_LEN)
    #undef CMD_BUF_LEN_INITDEVICE
    #define CMD_BUF_LEN_INITDEVICE VPP_CMD_PAGE_MAX_LEN
    #endif

    /* Buffer on stack to compose the HBI commands (worst case senario) */
    uint16 cmdBuff[CMD_BUF_LEN_INITDEVICE];

    /* Issue any basic commands necessary */
    /* Start DTMF detection on all channels */
    cmdBuff[offset++] = VPP_START_DTMF_DET(1, 0);
    #ifdef DEBUG_VPP_API
    term_printf("Started DTMF Detection\n");
    #endif /* DEBUG_VPP_API */

    /* Generate device commands to load/select AC, DC and Ring profiles */
    /* Note that the first location in the buffer is reserved for the
     * overall length */
    if(GenerateMailBoxProfile(VP_ALL_LINES, VP_PROFILE_AC, pAcProfile,
        &cmdBuff[0], &offset, pDevCtx) != TRUE) {
        return VP_STATUS_FAILURE;
    }
    #ifdef DEBUG_VPP_API_PROFILE
    term_printf("Wrote AC Profile: Length = %d\n", offset);
    #endif /* DEBUG_VPP_API_PROFILE */

    if(GenerateMailBoxProfile(VP_ALL_LINES, VP_PROFILE_DC, pDcProfile,
        &cmdBuff[0], &offset, pDevCtx) != TRUE) {
        return VP_STATUS_FAILURE;
    }
    #ifdef DEBUG_VPP_API_PROFILE
    term_printf("Wrote DC Profile: Length = %d\n", offset);
    #endif /* DEBUG_VPP_API_PROFILE */

    if(GenerateMailBoxProfile(VP_ALL_LINES, VP_PROFILE_RING, pRingProfile,
        &cmdBuff[0], &offset, pDevCtx) != TRUE) {
        return VP_STATUS_FAILURE;
    }
    #ifdef DEBUG_VPP_API_PROFILE
    term_printf("Wrote Ring Profile: Length = %d\n", offset);
    #endif /* DEBUG_VPP_API_PROFILE */

    /* Write the total command length */
    offset = offset - 1; /* Offset always points to next free location */
    cmdBuff[0] = offset<<1; /* Length is in bytes (length of commands does not
                             * include length field itself)
                             */

    /* BEGIN CRITICAL SECTION */
    VpSysEnterCritical(deviceId, VP_HBI_CRITICAL_SEC);

    /* Write the PLCK register to VPP */
    if(pDevProfile != VP_PTABLE_NULL){
        data = (pDevProfile[VPP_DEVPRF_PCLK_MSBI]<<8)
            + pDevProfile[VPP_DEVPRF_PCLK_LSBI];

        if(!VpHbiWr(deviceId, HW_Reg_PCLKSEL, &data)){
            retVal = VP_STATUS_ERR_HBI;
        }
    }

    if(retVal == VP_STATUS_SUCCESS) {
        /* Write the HBI commands composed above */
        retVal = IssueHbiCommandNoCritical(deviceId, &cmdBuff[0], offset);

        /* Set a flag so that we know what to do when an event arrives at the of
         * these command excecution by VPP.
         */
        ((VpVppDeviceObjectType *)pDevCtx->pDevObj)->deviceInitOngoing = TRUE;
    }

    VpSysExitCritical(deviceId, VP_HBI_CRITICAL_SEC);
    /* END CRITICAL SECTION */

    return retVal;
} /* VppInitDevice() */

/*
 * VppConfigLine()
 * This function configures a line with given profiles.
 *
 * Preconditions:
 * Should be called after initializing the device.
 *
 * Postconditions:
 * Updates the device profiles.
 */
static VpStatusType
VppConfigLine(
    VpLineCtxType *pLineCtx,
    VpProfilePtrType pAcProfile,        /* AC Profile Selector     */
    VpProfilePtrType pDcProfile,        /* DC Profile Selector     */
    VpProfilePtrType pRingProfile       /* Ring Profile Selector   */
    )
{
    #define CMD_BUF_LEN_INITLINE    (1 + VPP_AC_PRF_LEN + VPP_SELECT_PRF_LEN + \
                VPP_DC_PRF_LEN +  VPP_SELECT_PRF_LEN + VPP_RING_PRF_LEN + \
                VPP_RINGCAD_PRF_LEN + VPP_SELECT_PRF_LEN + 2) /* Some dummy */

    /* Buffer on stack to compose the HBI commands (worst case senario) */
    uint16 cmdBuff[CMD_BUF_LEN_INITDEVICE];

    VpVppLineObjectType *pLineObj = pLineCtx->pLineObj;
    uint8 line = pLineObj->channelId;
    VpDevCtxType *pDevCtx = pLineCtx->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    VpStatusType retVal;

    /* Because the first word is reserved for length of all commands */
    uint8 offset = 1;

    /* Generate device commands to load/select AC profile */
    if(GenerateMailBoxProfile(line, VP_PROFILE_AC, pAcProfile, &cmdBuff[0],
        &offset, pDevCtx) != TRUE) {
        return VP_STATUS_FAILURE;
    }

    /* Generate device commands to load/select DC profile */
    if(GenerateMailBoxProfile(line, VP_PROFILE_DC, pDcProfile, &cmdBuff[0],
        &offset, pDevCtx) != TRUE) {
        return VP_STATUS_FAILURE;
    }

    /* Generate device commands to load/select Ring profile */
    if(GenerateMailBoxProfile(line, VP_PROFILE_RING, pRingProfile, &cmdBuff[0],
        &offset, pDevCtx) != TRUE) {
        return VP_STATUS_FAILURE;
    }

    /* Write the total command length */
    offset = offset - 1; /* Offset always points to next free location */
    cmdBuff[0] = offset<<1; /* Length is in bytes (length of commands does not
                             *  include length field itself) */

    retVal = IssueHbiCommand(deviceId, cmdBuff, offset);

    return retVal;
} /* VppConfigLine() */

/*
 * VppInitRing()
 * This function initializes a line with given ringing related profiles.
 *
 * Preconditions:
 * Should be called after initializing the device.
 *
 * Postconditions:
 * Updates the device profiles.
 */
static VpStatusType
VppInitRing(
    VpLineCtxType *pLineCtx,       /**< Pointer to line context  */
    VpProfilePtrType pCadProfile,  /**< Ringing Cadence profile pointer or
                                    * pointer table index
                                    */
    VpProfilePtrType pCidProfile   /**< Caller ID profile pointer or pointer
                                    * table index
                                    */
    )
{
    #define CMD_BUF_LEN_INITRING    (1 + VPP_RING_PRF_LEN + \
        VPP_RINGCAD_PRF_LEN + VPP_SELECT_PRF_LEN + VPP_CID_PRF_LEN + \
        VPP_SELECT_PRF_LEN + 2) /* Some dummy */

    /* Buffer on stack to compose the HBI commands (worst case senario) */
    uint16 cmdBuff[CMD_BUF_LEN_INITDEVICE];

    VpVppLineObjectType *pLineObj = pLineCtx->pLineObj;
    uint8 line = pLineObj->channelId;
    VpDevCtxType *pDevCtx = pLineCtx->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    uint8 offset = 1; /* Because the first word is reserved for length
                       * of all commands */
    VpStatusType retVal;

    /* Generate device commands to load/select Ring cadence profile */
    if(GenerateMailBoxProfile(line, VP_PROFILE_RINGCAD, pCadProfile,
                                &cmdBuff[0], &offset, pDevCtx) != TRUE) {
        return VP_STATUS_FAILURE;
    }

    /* Generate device commands to load/select CID profile */
    if(GenerateMailBoxProfile(line, VP_PROFILE_CID, pCidProfile, &cmdBuff[0],
                                &offset, pDevCtx) != TRUE) {
        return VP_STATUS_FAILURE;
    }

    /* Write the total command length */
    offset = offset - 1; /* Offset always points to next free location */
    cmdBuff[0] = offset<<1; /* Length is in bytes (length of commands does not
                             *  include length field itself) */

    retVal = IssueHbiCommand(deviceId, cmdBuff, offset);

    return retVal;
} /* VppInitRing() */

/*
 * VppInitProfile()
 * This function initializes profile table.
 *
 * Preconditions:
 * None.
 *
 * Postconditions:
 * None.
 */
static VpStatusType
VppInitProfile(
    VpDevCtxType *pDevCtx,                  /* Device context to be used */
    VpProfileType type,                 /* Type of profile to load */
    VpProfilePtrType pProfileIndex,     /* Profile index selector */
    VpProfilePtrType pProfile           /* Pointer to the profile data */
    )
{
    /* Buffer on stack to compose the HBI commands (worst case senario); 1 for
     * length
     */
    uint16 cmdBuff[2 + VPP_MAX_PROFILE_LEN];

    /* Because the first word is reserved for length of all commands */
    uint8 offset = 1;

    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    VpStatusType retVal;
    VppProfileType vppPrfType;
    uint8 length;
    int index;

    if(pProfileIndex == VP_PTABLE_NULL) {
        return VP_STATUS_SUCCESS; /* Nothing to do */
    }
    /* Basic error checking */
    if((type == VP_PROFILE_DEVICE) || (type == VP_PROFILE_FXO_CONFIG)
     || (type >= VP_NUM_PROFILE_TYPES)) {
       /* Profiles that are not supported */
        return VP_STATUS_INVALID_ARG;
    }
    index = GetProfileIndex(pProfileIndex);
    if(index < 0) {
        /* Invalid profile index */
        return VP_STATUS_INVALID_ARG;
    }
    if(index >= GetProfileTableMaxCount(type)) {
        /* Invalid profile index */
        return VP_STATUS_INVALID_ARG;
    }
    if(IsItValidProfile(pProfile, type) == FALSE){
        return VP_STATUS_FAILURE; /* Invalid profile */
    }

    /* Ringing and Ringing cadence profile are to be treated seperately */
    if(type == VP_PROFILE_RING) {
        pDevObj->pRingingProfileTable[index] = pProfile;
        /* Note: The act of loading a profile table entry does not make it an
         * active one
         */
        return VP_STATUS_SUCCESS;   /* Because this is a software table */
    } else if(type == VP_PROFILE_RINGCAD) {
        pDevObj->pRingingCadProfileTable[index] = pProfile;
        /* Note: The act of loading a profile table entry does not make it an
         * active one
         */
        return VP_STATUS_SUCCESS; /* Because this is a software table */
    }

    /* Compose the profile set command */
    length = GET_PROFILE_LEN(pProfile);
    vppPrfType = GET_PROFILE_TYPE(pProfile);
    cmdBuff[offset++] = VPP_SET_PRF_CMD(vppPrfType);
    cmdBuff[offset++] = (index<<8) + length;
    ConvertAndAppendPrfData(&pProfile[4], length, cmdBuff, &offset);

    /* Write the total command length */
    offset = offset - 1; /* Offset always points to next free location */

    /* Length is in bytes (length of commands does not include the length field
     * itself)
     */
    cmdBuff[0] = offset<<1;

    retVal = IssueHbiCommand(deviceId, cmdBuff, offset);
    return retVal;
} /* VppInitProfile() */

/******************************************************************************
 *                   VPP Specific Control Functions                           *
 ******************************************************************************/
/**
 * VppSetLineState()
 *  Sets a line controlled by the VPP into the given state.
 *
 * Refer to the VP API User's Guide for details about this function.
 */
static VpStatusType
VppSetLineState(
    VpLineCtxType *pLineCtx,
    VpLineStateType state
    )
{
    uint16 cmdBuf[2];

    VpVppLineObjectType *pLineObj = pLineCtx->pLineObj;
    VpDevCtxType *pDevCtx = pLineCtx->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    switch(state) {
        case VP_LINE_STANDBY:
        case VP_LINE_TIP_OPEN:
        case VP_LINE_ACTIVE:
        case VP_LINE_ACTIVE_POLREV:
        case VP_LINE_OHT:
        case VP_LINE_OHT_POLREV:
        case VP_LINE_TALK:
        case VP_LINE_TALK_POLREV:
        case VP_LINE_RINGING:
        case VP_LINE_RINGING_POLREV:
        case VP_LINE_DISCONNECT:
            /* Length of the command */
            cmdBuf[0] = (VPP_SET_STATE_CMD_LEN + 1)<<1;
            cmdBuf[1] = VPP_SET_STATE_CMD(0, pLineObj->channelId,
                ConvertApiState2VppState(state));

            return IssueHbiCommand(deviceId, cmdBuf, VPP_SET_STATE_CMD_LEN + 1);

        default:
            return VP_STATUS_INVALID_ARG;
    }
}

/**
 * VppSetLineTone()
 *  Places a cadenced tone on the indicated line.
 *
 * Refer to the VP-API User's Guide for details about this function.
 */
static VpStatusType
VppSetLineTone(
    VpLineCtxType *pLineCtx,
    VpProfilePtrType pToneProfile,
    VpProfilePtrType pCadProfile,
    VpDtmfToneGenType *pDtmfControl
    )
{
    #define CMD_BUF_LEN_SET_TONE (1 + VPP_TONE_PRF_LEN + VPP_SELECT_PRF_LEN + \
            VPP_TONECAD_PRF_LEN + VPP_SELECT_PRF_LEN + 5) /* Some dummy */

    /* Buffer on stack to compose the HBI commands (worst case senario) */
    uint16 cmdBuff[CMD_BUF_LEN_SET_TONE];

    VpVppLineObjectType *pLineObj = pLineCtx->pLineObj;
    uint8 line = pLineObj->channelId;
    VpDevCtxType *pDevCtx = pLineCtx->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    /* Because the first word is reserved for length of all commands */
    uint8 offset = 1;
    VpStatusType retVal = VP_STATUS_SUCCESS;

    /* Generate device commands to load/select Tone and cadence profiles */
    /* Note that the first location in the buffer is reserved for the overall
     * length
     */
    if(GenerateMailBoxProfile(line, VP_PROFILE_TONE, pToneProfile, &cmdBuff[0],
        &offset, pDevCtx) != TRUE) {

        return VP_STATUS_FAILURE;
    }
    #ifdef DEBUG_VPP_API_PROFILE
    term_printf("Wrote Tone Profile: Length = %d\n", offset);
    #endif /* DEBUG_VPP_API_PROFILE */

    if(GenerateMailBoxProfile(line, VP_PROFILE_TONECAD, pCadProfile,
        &cmdBuff[0], &offset, pDevCtx) != TRUE) {

        return VP_STATUS_FAILURE;
    }
    #ifdef DEBUG_VPP_API_PROFILE
    term_printf("Wrote Tone Cadence Profile: Length = %d\n", offset);
    #endif /* DEBUG_VPP_API_PROFILE */

    /* Now issue Start/Stop tone generation command  */
     if(pCadProfile != VP_PTABLE_NULL) {

        /* DevNotes: Before we start a cadence stop anything that is on-going;
         * This seems to make it work right else the old sequence seems to
         * remain. */
        cmdBuff[offset++] = VPP_STOP_TONE_GEN_CH(line);

        /* Tone needs to be started */
        cmdBuff[offset++] = VPP_START_TONE_GEN_CH(line);
     } else {
        /* Tone needs to be stopped Note API is not keeping track if the tone
         * was already started to be able to stop now. */
        cmdBuff[offset++] = VPP_STOP_TONE_GEN_CH(line);
        /* cmdBuff[offset++] = VPP_START_TONE_GEN_CH(line); */
     }

    /* Write the total command length */
    offset = offset - 1; /* Offset always points to next free location */

    /* Length is in bytes (length of commands does not include the length field
     * itself)
     */
    cmdBuff[0] = offset<<1;

    retVal = IssueHbiCommand(deviceId, cmdBuff, offset);
    return retVal;
} /* VppSetLineTone() */


/**
 * VppSetOption()
 * This function is used to set various options that are supported by VPP.
 * For a detailed description of which options are available for VPP please
 * see VP-API user guide.
 *
 * Preconditions:
 * Device/Line context should be created and initialized. For applicable devices
 * bootload should be performed before calling the function.
 *
 * Postconditions:
 * This function sets the requested option.
 */
#define MAX_SET_OPT_CMD_LEN 20

static VpStatusType
VppSetOption(
    VpLineCtxType *pLineCtx,
    VpDevCtxType *pDevCtx,
    VpOptionIdType option,
    void *value)
{
    VpVppLineObjectType *pLineObj;
    VpDevCtxType *pDevCtxLocal;
    VpVppDeviceObjectType *pDevObj;
    VpDeviceIdType deviceId;

    uint16 cmdLen = 1;
    uint16 cmdBuff[MAX_SET_OPT_CMD_LEN];
    VpStatusType retval = VP_STATUS_SUCCESS;
    uint8 line = 0;
    bool broadcast = FALSE;
    VpOptionUsTranscoderType *usCodec;
    VpOptionDsTranscoderType *dsCodec;
    VpOptionEchoCancelerType *echoOpt;

    if(pLineCtx != VP_NULL) {
        pDevCtxLocal = pLineCtx->pDevCtx;
        pDevObj = pDevCtxLocal->pDevObj;
        deviceId = pDevObj->deviceId;
        pLineObj = pLineCtx->pLineObj;
        line = pLineObj->channelId;
    } else {        /* Device context pointer must be valid */
        pDevObj = pDevCtx->pDevObj;
        deviceId = pDevObj->deviceId;

        /* For device options and for line specific options (when device context
         * is passed) set the requested option to the device and to all lines.
         */
        broadcast = TRUE;
    }

    switch (option) {
        case VP_OPTION_ID_US_TRANSCODEC: {
            cmdBuff[cmdLen++] = VPP_SETOPT_US_CODEC(broadcast, line);
            usCodec = value;
            cmdBuff[cmdLen++] = ((usCodec->packetType & 0xff)<<8) +
                                usCodec->packetSize;
            cmdBuff[cmdLen++] = usCodec->silenceSupression;
            break;
        }
        case VP_OPTION_ID_DS_TRANSCODEC: {
            cmdBuff[cmdLen++] = VPP_SETOPT_DS_CODEC(broadcast, line);
            dsCodec = value;
            cmdBuff[cmdLen++] = ((dsCodec->packetType & 0xff)<<8) +
                                dsCodec->packetSize;
            cmdBuff[cmdLen++] = ((0x07  & dsCodec->framesToMute)<<8) +
                                ((0x01f & dsCodec->ramp)<<3) +
                                (0x07 & dsCodec->plc);
            break;
        }
        case VP_OPTION_ID_ECHO_CANCELER: {
            cmdBuff[cmdLen++] = VPP_SETOPT_ECHO_CNCL(broadcast, line);
            echoOpt = value;
            cmdBuff[cmdLen++] = ((0x07 & echoOpt->tailLength)<<8) +
                                ((0x01 & echoOpt->toneDisable)<<5) +
                                ((0x01 & echoOpt->echoCanDisable)<<4) +
                                ((0x01 & echoOpt->adaptDisable)<<3) +
                                ((0x01 & echoOpt->resetHRegister)<<2) +
                                ((0x01 & echoOpt->cngDisable)<<1) +
                                (0x01 & echoOpt->nlpDisable);
            break;
        }
        case VP_OPTION_ID_CLR_PKT_CNTR: {
            cmdBuff[cmdLen++] = VPP_SETOPT_CLR_PKT_CNTR(broadcast, line);
            break;
        }
        default: {
            return VP_STATUS_INVALID_ARG;
        }
    }

    if(retval == VP_STATUS_SUCCESS) {
        cmdLen = cmdLen - 1; /* length always points to next free location */
        cmdBuff[0] = cmdLen<<1; /* Length is in bytes (length of commands does
                                 * not include length field itself) */
        retval = IssueHbiCommand(deviceId, cmdBuff, cmdLen);
    }

    return retval;
} /* VppSetOption() */

/******************************************************************************
 *                   VPP Specific Status and Query Functions                  *
 ******************************************************************************/
/**
 * VppGetEvent()
 *  Gets an event (if available) from the VPP.
 *
 * Refer to the VP-API User's Guide for events that can be obtained from this
 * function.
 */
static bool
VppGetEvent(
    VpDevCtxType *pDevCtx,
    VpEventType *pEvent)
{
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    uint8 channelId;
    uint16 eventInfo[2];
    bool eventEdge;
    uint8 eventData;
    uint8 eventType;
    VpStatusType status = VP_STATUS_SUCCESS;
    bool retVal = FALSE;
    uint16 cmdBuf[2]; /* Temporary command buffer */

    VpSysEnterCritical(deviceId, VP_HBI_CRITICAL_SEC);/* BEGIN CRITICAL
                                                       * SECTION */

    if(!VpHbiRd(deviceId, HW_Reg_INTIND_AND_INTPARAM, &eventInfo[0])){
        ExitOnHbiError(__func__);
    }

    VpSysExitCritical(deviceId, VP_HBI_CRITICAL_SEC); /* END CRITICAL SECTION */

    /* Fill the event with default parameters */
    pEvent->channelId = 0;
    pEvent->pLineCtx = VP_NULL;
    pEvent->deviceId = deviceId;
    pEvent->pDevCtx = pDevCtx;
    pEvent->eventCategory = 0;
    pEvent->eventId = 0;
    pEvent->parmHandle = 0;
    pEvent->eventData = 0;

    if(eventInfo[0] == 0) {
        /* No event */
        return FALSE;
    } else {
        #ifdef DEBUG_VPP_API_EVENT
        term_printf("Received Event: 0x%x 0x%x\n", eventInfo[0], eventInfo[1]);
        #endif /* DEBUG_VPP_API_EVENT */
    }

    if((eventInfo[0] & 0x8000) == 0) {
        /* Software generated event */
        /* Extract various components of the event */
        channelId = (eventInfo[0] & 0x7000)>>12;

        /* need change if imars channel mapping changes */
/*        channelId = channelId % VPP_MAX_NUM_LINES;    */

        if(channelId >= VPP_MAX_NUM_LINES) {
            #ifdef DEBUG_VPP_API
            term_printf("ERROR: Event channel ID = %d received\n", channelId);
            #endif /* DEBUG_VPP_API */
        }
        eventData = (eventInfo[0] & 0x0f00)>>8;
        eventEdge = (eventInfo[0] & 0x0080)>>7;
        eventType = eventInfo[0] & 0x007f;
        #ifdef DEBUG_VPP_API_EVENT
        term_printf("Event eventData = 0x%x, eventEdge = 0x%x,"
                    " eventType = 0x%x\n", eventData, eventEdge, eventType);
        #endif /* DEBUG_VPP_API_EVENT */

        switch (eventType) {
            case VPP_EVID_INIT_CMP: {
                /* We have received boot complete event; VPP however does not
                 * copy the version information to upstream mailbox; Hence Issue
                 *  Get Version status information command */

                #ifdef DEBUG_VPP_API
                term_printf("Received VPP_EVID_INIT_CMP event\n");
                #endif /* DEBUG_VPP_API */
                retVal = FALSE; /* No event; since this function
                                 * is consuming it */

                VpSysEnterCritical(deviceId, VP_HBI_CRITICAL_SEC);  /* BEGIN
                                                           * CRITICAL SECTION */
                /* VPP may not have enabled the mail box event masks;
                 * So enable them */

                SetDefaultMasks(deviceId);

                cmdBuf[0] = 2 * (VPP_GETSTS_VERSION_CMD_LEN + 1);
                cmdBuf[1] = VPP_GETSTS_VERSION_CMD;
                #ifdef DEBUG_VPP_API
                term_printf("Issuing Get version command\n");
                #endif /* DEBUG_VPP_API */
                status = IssueHbiCommandNoCritical(deviceId, cmdBuf,
                                                VPP_GETSTS_VERSION_CMD_LEN+1);
                if(status == VP_STATUS_SUCCESS) {
                    pDevObj->bootCompleteProcssing = TRUE;
                }
                VpSysExitCritical(deviceId, VP_HBI_CRITICAL_SEC); /* END
                                                        * CRITICAL SECTION */

                retVal = FALSE;/* No event; since this function is
                                * consuming it*/
                break;
            }
            case VPP_EVID_CMD_FAILED: {
                #ifdef DEBUG_VPP_API
                term_printf("WARNING: Event not understood 0x%x 0x%x\n",
                                eventInfo[0], eventInfo[1]);
                #endif /* DEBUG_VPP_API */
                break;
            }
            case VPP_EVID_MAILBOX_RDY: {
                switch (eventData) {
                    case VPP_HBI_CMDMB_PAGE: {
                        #ifdef DEBUG_VPP_API_MAILBOX
                        term_printf("VPP returned command mailbox\n");
                        #endif /* DEBUG_VPP_API_MAILBOX */
                        if(pDevObj->deviceInitOngoing == TRUE) {
                            /* Return of command mailbox is used to flag the
                             * end of VPP processing the device init command
                             * and to be able to generate Cal complete event. */
                            /* BEGIN CRITICAL SECTION */
                            VpSysEnterCritical(deviceId, VP_CODE_CRITICAL_SEC);
                            pDevObj->deviceInitOngoing = FALSE;
                            VpSysExitCritical(deviceId, VP_CODE_CRITICAL_SEC);
                            /* END CRITICAL SECTION */
                            pEvent->eventCategory = VP_EVCAT_RESPONSE;
                            pEvent->eventId = VP_DEV_EVID_DEV_INIT_CMP;
                            pEvent->eventData = 1; /* There can only be
                                                     * one CODEC per VPP */
                            retVal = TRUE;
                        }
                        break;
                    }
                    case VPP_HBI_RSPMB_PAGE: {
                        /* Generate a event based on the type of response */
                        status = GenerateReponseMailBoxEvents(pDevCtx, pEvent);
                        if(pEvent->eventId != 0){
                            /* There is some valid event */
                            retVal = TRUE;
                        }
                        break;
                    }
                    case VPP_HBI_CH1US_PAGE:
                    case VPP_HBI_CH2US_PAGE: {
                        /* Upstream packet available */
                        pEvent->channelId = channelId;
                        pEvent->pLineCtx = pDevCtx->pLineCtx[channelId];
                        pEvent->eventCategory = VP_EVCAT_PACKET;
                        pEvent->eventId = VP_LINE_EVID_US_PKT_RDY;
                        if ( channelId == 0)    {
                           pEvent->eventData = VP_STREAM_0; /* Stream Id */
                        } else {
                           pEvent->eventData = VP_STREAM_1; /* Stream Id */
                        }
                        retVal = TRUE;
                        break;
                    }
                    case VPP_HBI_CH12US_PAGE:
                    case VPP_HBI_CH22US_PAGE: {
                        /* Upstream packet available */
                        pEvent->channelId = channelId;
                        pEvent->pLineCtx = pDevCtx->pLineCtx[channelId];
                        pEvent->eventCategory = VP_EVCAT_PACKET;
                        pEvent->eventId = VP_LINE_EVID_US_PKT_RDY;
                        if ( channelId == 0)    {
                           pEvent->eventData = VP_STREAM_2; /* Stream Id */
                        } else {
                           pEvent->eventData = VP_STREAM_3; /* Stream Id */
                        }
                        retVal = TRUE;
                        break;
                    }
                    case VPP_HBI_CH1DS_PAGE:
                    case VPP_HBI_CH2DS_PAGE: {
                        /* Need downstream packet event */
                        pEvent->channelId = channelId;
                        pEvent->pLineCtx = pDevCtx->pLineCtx[channelId];
                        pEvent->eventCategory = VP_EVCAT_PACKET;
                        pEvent->eventId = VP_LINE_EVID_NEED_DS_PKT;
                        if ( channelId == 0)    {
                           pEvent->eventData = VP_STREAM_0; /* Stream Id */
                        } else {
                           pEvent->eventData = VP_STREAM_1; /* Stream Id */
                        }
                        retVal = TRUE;
                        break;
                    }
                    case VPP_HBI_CH12DS_PAGE:
                    case VPP_HBI_CH22DS_PAGE: {
                        /* Need downstream packet event */
                        pEvent->channelId = channelId;
                        pEvent->pLineCtx = pDevCtx->pLineCtx[channelId];
                        pEvent->eventCategory = VP_EVCAT_PACKET;
                        pEvent->eventId = VP_LINE_EVID_NEED_DS_PKT;
                        if ( channelId == 0)    {
                           pEvent->eventData = VP_STREAM_2; /* Stream Id */
                        } else {
                           pEvent->eventData = VP_STREAM_3; /* Stream Id */
                        }
                        retVal = TRUE;
                        break;
                    }
                    default: break; /* Nothing to do for unhandled mailbox ownership changes */
                }
                break;
            }
            case VPP_EVID_HOOK_SWITCH: {
                pEvent->eventCategory = VP_EVCAT_SIGNALING;
                pEvent->channelId = channelId;
                pEvent->pLineCtx = pDevCtx->pLineCtx[channelId];
                pEvent->parmHandle = eventInfo[1]; /* Time stamp */
                if(eventEdge == 1) {
                    pEvent->eventId = VP_LINE_EVID_HOOK_OFF;
                } else {
                    pEvent->eventId = VP_LINE_EVID_HOOK_ON;
                }
                retVal = TRUE;
                break;
            }
            case VPP_EVID_DTMF_DIGIT_DET: {
                pEvent->eventCategory = VP_EVCAT_SIGNALING;
                pEvent->eventId = VP_LINE_EVID_DTMF_DIG;
                pEvent->channelId = channelId;
                pEvent->pLineCtx = pDevCtx->pLineCtx[channelId];
                pEvent->parmHandle = eventInfo[1]; /* Time stamp */
                pEvent->eventData = eventData + (eventEdge<<4); /* Digit
                                                            * detected + Edge */
                retVal = TRUE;
                break;
            }
            case VPP_EVID_PKT_MISS: {
                pEvent->eventCategory = VP_EVCAT_PACKET;
                pEvent->eventId = VP_LINE_EVID_PKT_LOST;
                /* #ifdef DEBUG_VPP_API */
                term_printf("PKT_LOST Stream = %d, EVTD = %d\n", channelId, eventData);
                /* #endif */ /* DEBUG_VPP_API */
				/* We need this because the event contains stream ID not channel ID*/
				if((channelId == 0) || (channelId == 2)) {
	                pEvent->channelId = 0;
	                pEvent->pLineCtx = pDevCtx->pLineCtx[0];

				} else if((channelId == 1) || (channelId == 3)){ 
	                pEvent->channelId = 1;
	                pEvent->pLineCtx = pDevCtx->pLineCtx[1];
				}
                pEvent->parmHandle = eventInfo[1]; /* Time stamp */
                pEvent->eventData = eventData;     /* voice stream & direction */
                retVal = TRUE;
                break;
            }
            default: {
                #ifdef DEBUG_VPP_API
                term_printf("WARNING: Event not understood 0x%.4x 0x%.4x\n",
                                eventInfo[0], eventInfo[1]);
                #endif /* DEBUG_VPP_API */
            }
        }

    } else {
        /* System event */
        /* It is possible that there is more than one system event at any
         * given point in time */

        /* DevNotes: Add code to handle sequencing of system events */
        #ifdef DEBUG_VPP_API
        term_printf("System Event: 0x%x\n", eventInfo[0]);
        #endif /* DEBUG_VPP_API */

        /* Parse the system events */
        if((eventInfo[0] & VPP_EVID_SYS_EV_OV_MASK) == VPP_EVID_SYS_EV_OV_MASK){
            pEvent->eventCategory = VP_EVCAT_FAULT;
            pEvent->eventId = VP_DEV_EVID_EVQ_OFL_FLT;
            retVal = TRUE;
            #ifdef DEBUG_VPP_API
            term_printf("EVENT: Event queue overflow.\n");
            #endif /* DEBUG_VPP_API */

        } else if((eventInfo[0] & VPP_EVID_SYS_WDT_MASK) ==
                    VPP_EVID_SYS_WDT_MASK) {
            pEvent->eventCategory = VP_EVCAT_FAULT;
            pEvent->eventId = VP_DEV_EVID_WDT_FLT;
            retVal = TRUE;
            #ifdef DEBUG_VPP_API
            term_printf("EVENT: Watchdog timer event.\n");
            #endif /* DEBUG_VPP_API */
        } else if(((eventInfo[0] & VPP_EVID_SYS_CFAIL_MASK) ==
                                        VPP_EVID_SYS_CFAIL_MASK) ||
                  ((eventInfo[0] & VPP_EVID_SYS_CFAILGT20_MASK) ==
                                        VPP_EVID_SYS_CFAILGT20_MASK)) {
            pEvent->eventCategory = VP_EVCAT_FAULT;
            pEvent->eventId = VP_DEV_EVID_CLK_FLT;
            retVal = TRUE;
            #ifdef DEBUG_VPP_API
            term_printf("EVENT: Clock failure event.\n");
            #endif /* DEBUG_VPP_API */
        } else if(((eventInfo[0] & VPP_EVID_SYS_PINT_MASK) ==
                                            VPP_EVID_SYS_PINT_MASK) ||
                  ((eventInfo[0] & VPP_EVID_SYS_LINT_MASK) ==
                                            VPP_EVID_SYS_LINT_MASK) ||
                  ((eventInfo[0] & VPP_EVID_SYS_HINT_MASK) ==
                                            VPP_EVID_SYS_HINT_MASK)) {

            pEvent->eventCategory = VP_EVCAT_FAULT;
            pEvent->eventId = VP_DEV_EVID_BAT_FLT;
            retVal = TRUE;

            /* DevNotes: which type of battery interrupt may need to be
             * specified.*/
            #ifdef DEBUG_VPP_API
            term_printf("EVENT: Battery failure event.\n");
            #endif /* DEBUG_VPP_API */
        } else {
            #ifdef DEBUG_VPP_API
            term_printf("WARNING: System event not understood 0x%x\n",
                            eventInfo[0]);
            #endif /* DEBUG_VPP_API */
        }
    }

    return retVal;
} /* VppGetEvent() */

/*
 * VppGetResults()
 * Copies the data corresponding to the specified event from the response
 * mailbox into the structure pointed to by 'pResults' and frees the mailbox.
 *
 * Preconditions:
 * This function assumes there is only one response outstanding in the response
 * buffer.
 *
 * Postconditions:
 * None
 */
static VpStatusType
VppGetResults(
    VpEventType *pEvent,
    void *pResults)
{
    VpDevCtxType *pDevCtx = pEvent->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    VpStatusType status;
    VpEventType tempEvent;
    uint16 givenCmpEv, readCmpEv;

    /* Obtain the type of event corresponding to response on the response
     * mail box */
    tempEvent = *pEvent; /* The following function overwrites only eventId
                          * and eventCat */
    status = GenerateReponseMailBoxEvents(pDevCtx, &tempEvent);

    if(pResults == VP_NULL) {
        /* User is trying to figure out what is the type of response in the
         * response mail box So copy the event corresponding to response on
         * the response mail box */
        *pEvent = tempEvent;
        return VP_STATUS_SUCCESS;
    }

    /* Basic error checking */
    if((status == VP_STATUS_MAILBOX_EMPTY) || (tempEvent.eventId == 0)) {
        /* No host readable response */
        return VP_STATUS_MAILBOX_EMPTY;
    }
    /* Combine eventId and category for easy comparision */
    givenCmpEv = pEvent->eventId +  pEvent->eventCategory;
    readCmpEv = tempEvent.eventId + tempEvent.eventCategory;
    if(givenCmpEv != readCmpEv){
        if(!(((givenCmpEv == VP_DEV_EVID_BOOT_CMP + VP_EVCAT_RESPONSE) ||
                (givenCmpEv == VP_DEV_EVID_CHKSUM + VP_EVCAT_TEST)) &&
             ((readCmpEv == VP_DEV_EVID_BOOT_CMP + VP_EVCAT_RESPONSE)  ||
                (readCmpEv == VP_DEV_EVID_CHKSUM + VP_EVCAT_TEST)))) {
            /* Make sure exceptions due to the way API code is implemented
             * does not error to be generated */
            return VP_STATUS_ERR_MAILBOX_DATA;
        }
    }

    /* Copy the data from response buffer to the given location */
    if(pEvent->eventCategory == VP_EVCAT_RESPONSE) {
        switch (pEvent->eventId) {
            case VP_DEV_EVID_BOOT_CMP:  {
                status = ReadVersionInfo(deviceId, pResults);
                break;
            }
            case VP_LINE_EVID_RD_LOOP:  {
                status = ReadLineCond(deviceId, pResults);
                break;
            }
            default: {
                status =  VP_STATUS_INVALID_ARG;
                break;
            }
        }
    } else  if(pEvent->eventCategory == VP_EVCAT_TEST) {
        switch (pEvent->eventId) {
            case VP_DEV_EVID_CHKSUM:    {
                status = ReadVersionInfo(deviceId, pResults);
                break;
            }
            default: {
                status =  VP_STATUS_INVALID_ARG;
                break;
            }
        }
    } else  if(pEvent->eventCategory == VP_EVCAT_PACKET) {
        switch (pEvent->eventId) {
            case VP_LINE_EVID_RD_PKT_STATS: {
                status = ReadPktStatistics(deviceId, pResults);
                break;
            }
            default: {
                status =  VP_STATUS_INVALID_ARG;
                break;
            }
        }
    }

    return status;
} /* VppGetResults() */

/*
 * VppGetLoopCond()
 * This function issues a command to VPP to retrieve the data from the device.
 *
 * Preconditions:
 * None
 *
 * Postconditions:
 * None
 */
static VpStatusType
VppGetLoopCond(
    VpLineCtxType *pLineCtx,
    uint16 handle)
{
    /* DevNotes: Note that "handle" is not inherently supported in the device.
     * So, we need a softare mechanism to be able to support it. */

    VpVppLineObjectType *pLineObj = pLineCtx->pLineObj;
    uint8 channelId = pLineObj->channelId;
    VpDevCtxType *pDevCtx = pLineCtx->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    uint16 cmdBuff[VPP_GETSTS_LINE_COND_CMD_LEN + 1 +
                    VPP_GETSTS_BAT_VOLT_CMD_LEN + 1 + 1];
    uint16 offset = 1;
    VpStatusType retVal;

    /* Prepare the command */
    cmdBuff[offset++] = VPP_GETSTS_LINE_COND_CMD(channelId);
    /* Since VPP device does not have battery voltages in this command,
     * issue another command */
    cmdBuff[offset++] = VPP_GETSTS_BAT_VOLT_CMD(channelId);

    /* Write the total command length */
    offset = offset - 1; /* Offset always points to next free location */
    cmdBuff[0] = offset<<1; /* Length is in bytes (length of commands does
                             *  not include length field itself) */

    retVal = IssueHbiCommand(deviceId, cmdBuff, offset);
    return retVal;
}


/*******************************************************************************
 * Packet Interface functions                                                  *
 ******************************************************************************/
/*
 * VppControlVoiceStream()
 * This function issues a command to start or stop a 3 way conference.
 *
 * Preconditions:
 * two phones already in TALK state.
 *
 * Postconditions:
 * Starts the 3rd party conference
 */
static VpStatusType
VppControlVoiceStream(
    VpLineCtxType *pLineCtx,
    uint8 streamId,
    VpVSConfControlType streamControl, /* Start, Stop the conference */
    VpVSConfModeType confMode)         /* Conference mode */
{
    uint16 cmdLen = 1;
    uint16 cmdBuff[MAX_SET_OPT_CMD_LEN];
    VpStatusType retval = VP_STATUS_SUCCESS;

    VpVppLineObjectType *pLineObj = pLineCtx->pLineObj;
    uint8 channelId = pLineObj->channelId;
    VpDevCtxType *pDevCtx = pLineCtx->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    if (streamControl == VP_VOICE_STREAM_START) {
       cmdBuff[cmdLen++] = VPP_START_3WAY_CONFERENCE(channelId);
       cmdBuff[cmdLen++] = (streamId & 0x7) + ((confMode & 0x0001)<<3);
    }
    else {
       cmdBuff[cmdLen++] = VPP_STOP_3WAY_CONFERENCE(channelId);
       cmdBuff[cmdLen++] = (streamId & 0x7);
    }
    if(retval == VP_STATUS_SUCCESS) {
        cmdLen = cmdLen - 1; /* length always points to next free location */
        cmdBuff[0] = cmdLen<<1; /* Length is in bytes (length of commands does
                                 * not include length field itself) */
        retval = IssueHbiCommand(deviceId, cmdBuff, cmdLen);
    }

    return retval;
} /* VppControlVoiceStream() */

/*
 * VppReadUpStreamPacket()
 * This function is used to read upstream voice packets from VPP.
 *
 * Preconditions:
 * The given buffer is expected to hold at least the maximum size of the packet
 * expected from the device. This function is expected to be called only if a
 *  packet is avaliable to be read (as indicated by the upstream packet event).
 *
 * Postconditions:
 * None
 */
static VpStatusType
VppReadUpStreamPacket(
    VpLineCtxType *pLineCtx,
    VpPktDataPtrType pPacketData,
    uint8 streamId)
{
    VpVppLineObjectType *pLineObj = pLineCtx->pLineObj;
    uint8 channelId = pLineObj->channelId;
    VpDevCtxType *pDevCtx = pLineCtx->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    uint8 mailBox = 0;

    /* term_printf("u%2d ", deviceId); */
    if ( channelId == 0)
    {
        if ( (streamId != VP_STREAM_0) && (streamId != VP_STREAM_2) )
        {
           return VP_STATUS_INVALID_VOICE_STREAM;
        }
    }
    else
    {
        if ( (streamId != VP_STREAM_1) && (streamId != VP_STREAM_3) )
        {
           return VP_STATUS_INVALID_VOICE_STREAM;
        }
    }
    if ( channelId == 0)
    {
        if(streamId == VP_STREAM_0) {
            mailBox = VPP_HBI_CH1US_PAGE;
        } else {
            mailBox = VPP_HBI_CH12US_PAGE;
        }
    }
    else
    {
        if(streamId == VP_STREAM_1) {
            mailBox = VPP_HBI_CH2US_PAGE;
        } else {
            mailBox = VPP_HBI_CH22US_PAGE;
        }
    }

    return ReadWritePackets(deviceId, TRUE, pPacketData, mailBox);
} /* VppReadUpStreamPacket() */

/*
 * VppWriteDownStreamPacket()
 * This function is used to write downstream voice packets to VPP.
 *
 * Preconditions:
 * The packet format is expected to in Legerity Packet format and is expected to
 * contain packet length. This function is expected to be called only if a
 *  packet is asked to be written (as indicated by the downstream packet event).
 *
 * Postconditions:
 * None
 */
static VpStatusType
VppWriteDownStreamPacket(
    VpLineCtxType *pLineCtx,
    VpPktDataPtrType pPacketData,
    uint8 streamId)
{
    VpVppLineObjectType *pLineObj = pLineCtx->pLineObj;
    uint8 channelId = pLineObj->channelId;
    VpDevCtxType *pDevCtx = pLineCtx->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    uint8 mailBox;

    /* term_printf("d%2d ", deviceId); */
    if ( channelId == 0)
    {
        if ( (streamId != VP_STREAM_0) && (streamId != VP_STREAM_2) )
        {
           return VP_STATUS_INVALID_VOICE_STREAM;
        }
    }
    else
    {
        if ( (streamId != VP_STREAM_1) && (streamId != VP_STREAM_3) )
        {
           return VP_STATUS_INVALID_VOICE_STREAM;
        }
    }
    if ( channelId == 0)
    {
        if(streamId == VP_STREAM_0) {
            mailBox = VPP_HBI_CH1DS_PAGE;
        } else {
            mailBox = VPP_HBI_CH12DS_PAGE;
        }
    }
    else
    {
        if(streamId == VP_STREAM_1) {
            mailBox = VPP_HBI_CH2DS_PAGE;
        } else {
            mailBox = VPP_HBI_CH22DS_PAGE;
        }
    }

    return ReadWritePackets(deviceId, FALSE, pPacketData, mailBox);
} /* VppWriteDownStreamPacket() */

/*
 * VppGetTimeStamp()
 * This function is used to read the timestamp information from the device.
 *
 * Preconditions:
 * None
 *
 * Postconditions:
 * None
 */
static VpStatusType
VppGetTimeStamp(
    VpDevCtxType *pDevCtx,
    uint16 *pTimeStamp)
{
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    VpSysEnterCritical(deviceId, VP_HBI_CRITICAL_SEC);/* BEGIN CRITICAL
                                                       * SECTION */

    if(!VpHbiRd(deviceId, VPP_Reg_TIMESTAMP, pTimeStamp)){
        ExitOnHbiError(__func__);
    }

    VpSysExitCritical(deviceId, VP_HBI_CRITICAL_SEC); /* END CRITICAL SECTION */

    return VP_STATUS_SUCCESS;
} /* VppGetTimeStamp() */

/*
 * VppGetTimeStamp()
 * This function is used to read the timestamp information from the device.
 *
 * Preconditions:
 * None
 *
 * Postconditions:
 * None
 */
static VpStatusType
VppReadPacketStatistics(
    VpLineCtxType *pLineCtx,
    uint16 handle)
{
    /* DevNotes: Note that "handle" is not inherently supported in the device.
     * So, we need a softare mechanism to be able to support it. */

    VpVppLineObjectType *pLineObj = pLineCtx->pLineObj;
    uint8 channelId = pLineObj->channelId;
    VpDevCtxType *pDevCtx = pLineCtx->pDevCtx;
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    uint16 cmdBuff[VPP_GETSTS_VERSION_CMD_LEN + 1 + 1];
    uint16 offset = 1;
    VpStatusType retVal;

    /* Prepare the command */
    cmdBuff[offset++] = VPP_GETSTS_PKT_STATS_CMD(channelId);

    /* Write the total command length */
    offset = offset - 1; /* Offset always points to next free location */
    cmdBuff[0] = offset<<1; /* Length is in bytes (length of commands does
                             * not include length field itself) */

    retVal = IssueHbiCommand(deviceId, cmdBuff, offset);
    return retVal;
} /* VppReadPacketStatistics() */


/*******************************************************************************
 * VPP specific helper functions                                               *
 ******************************************************************************/
/*
 * ReadWritePackets()
 * This function is used to read/write packets to VPP.
 *
 * Preconditions:
 * This function is assumed to be called in resopnse to packet events.
 * Packet buffer is expected to contain the packet or assumed to contain enough
 * space to hold a packet.
 *
 * Postconditions:
 * None
 */
static VpStatusType
ReadWritePackets(
    VpDeviceIdType deviceId,        /* device Id to which we need to talk */
    bool readFlag,                  /* == TRUE, Read a packet, == FALSE,
                                     * Write a packet */
    VpPktDataPtrType pPacketData,   /* Pointer to location where packet has to
                                     * be read from or written to */
    uint8 mailBox)                  /* Mailbox from where packet needs to be
                                     * accessed */
{
    VpStatusType status = VP_STATUS_SUCCESS;
    uint8 length = 0;

 VpSysEnterCritical(deviceId, VP_HBI_CRITICAL_SEC);/* BEGIN CRITICAL
                                                       * SECTION */

    /* Acquire mailbox; Copy the commands and release the mailbox */
    if((status = AcquireMailBox(deviceId, mailBox)) == VP_STATUS_SUCCESS) {

        if(readFlag == TRUE) {
            /* Read a packet */
            /* First read the packet header and extract the number of words
             * to be read; i.e, read first two bytes. */
            if(VpHbiRd8(deviceId, mailBox, 0, 0, pPacketData) == FALSE){
                ExitOnHbiError(__func__);
            }
            length = (pPacketData[1] - 2)>>1;
            if(length != 0){
                /* Read the remaining packet */
                if(VpHbiRd8(deviceId, mailBox, 1, length, &pPacketData[2]) ==
                    FALSE){
                    ExitOnHbiError(__func__);
                }
            }
        } else {
            /* Write a packet */
            length = pPacketData[1];
            if((length & 0x01) == 0x01){
                status = VP_STATUS_FAILURE;/* There is some error in
                                            * the Packet */
            } else {
                length = length>>1; /*As per Legerity Packet format; Packet
                * length does not include packet header itself and our HAL
                * functions take one less number of words to be written. */
                if(VpHbiWr8(deviceId, mailBox, 0, length, pPacketData) ==FALSE){
                    ExitOnHbiError(__func__);
                }
            }
        }

        /* Now release the maibox */
        status = ReleaseMailBox(deviceId, mailBox);
    }

    VpSysExitCritical(deviceId, VP_HBI_CRITICAL_SEC); /* END CRITICAL SECTION */

            #if 0
            if(readFlag == TRUE)  {
                term_printf("u%1d%1d ", deviceId, mailBox);
            } else {
                term_printf("d%1d%1d ", deviceId, mailBox);
            }
            #endif

    return status;
}


/*
 * GenerateMailBoxProfile()
 * This function takes the given profile pointer or profile table index and
 * generates appropriate VPP HBI commands to load the given profile to the
 * device.
 *
 * Preconditions:
 * The temporary buffer that is passed to this function is assumed to have
 * enough storage room to store the HBI command. The start index from where
 * the generated command needs to be stroed needs to be passed to this function.
 *
 * Postconditions:
 * If the function completes successfully, then it returns TRUE and stores the
 * necessary commands to store the profile to the part. It also updates the
 * length of the buffer after storing the profile command.
 */
static bool                         /* Returns TRUE if completed successfully */
GenerateMailBoxProfile(
    uint8 channelId,                /* == 0, 1 => loads to indicated channel
                                     *  (profile table load + profile select
                                     *  command);
                                     * == 0xff => broadcast to all channels
                                     *  (profile table load + profile select
                                     *  command);
                                     * == 0xaa => loads only profile table
                                     *  (no profile select command) */
    VpProfileType type,             /* Specifies the profile type */
    VpProfilePtrType pProfile,      /* Given Profile pointer */
    uint16 *pCmdBuffer,             /* Temporary command buffer to store the
                                     * HBI command data */
    uint8 *offset,                  /* Starting offset from where the data has
                                     * to be stored */
    VpDevCtxType *pDevCtx)          /* VPP device Object */
{
    bool useProfileTable = FALSE;
    int profileIndex;
    uint16 broadCast = 0;
    uint8 length = 0;
    VppProfileType vppPrfType = VPP_NUM_PROFILE_TYPES;
    VpProfilePtrType pRingPrf = VP_NULL, pRingCadPrf = VP_NULL;
    int i;
    VpVppLineObjectType *pLineObj;
    VpProfileDataType defaultRingCadencePrf[] = {VPP_DEFAULT_RING_ON_CAD_PRF};
    VpProfileDataType defaultRingPrf[] = {VPP_DEFAULT_RING_PRF};
    bool retVal = FALSE;

    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;

    /* First perform basic error checking */
    if(pProfile == VP_PTABLE_NULL){
        /* Nothing to do... */
        return TRUE;
    }
    if((channelId >= VPP_MAX_NUM_LINES) && (channelId != VP_ALL_LINES)){
       /* Not a supported channel */
       return FALSE;
    }
    if((type >= VP_NUM_PROFILE_TYPES) || (type == VP_PROFILE_FXO_CONFIG) ||
       (type == VP_PROFILE_DEVICE)){
       /* Profiles not supported for VPP */
       return FALSE;
    }

    if(channelId == VP_ALL_LINES) {
        broadCast = 1;
        channelId = 0;
    }

    /* Determine if a profile index is passed */
    profileIndex = GetProfileIndex(pProfile);
    if(profileIndex >= 0) {
        useProfileTable = TRUE;
    }
    if((useProfileTable == TRUE) && (type != VP_PROFILE_RING) &&
        (type != VP_PROFILE_RINGCAD)){

        /* There is only one entry for each type of Caller ID profile;
         * So Select profile command is not necessary; CID profiles are
         * automatically selected. */
        if(type == VP_PROFILE_CID) {
            return TRUE;
        }

        /* Select the indicated profile */
        /* Verify the profile index */
        if(profileIndex >= GetProfileTableMaxCount(type)){
            return FALSE;
        }

        /* Write the necessary commands to load the desired bank selection */
        /* Profiles supported directly by the device; Issue Profile
         * select commad */
        if(*offset + 2 >= VPP_CMD_PAGE_MAX_LEN) {
            return FALSE; /* Not enough space to write the command */
        }
        pCmdBuffer[(*offset)++] = VPP_SELECT_PRF_CMD(broadCast, channelId,
                                    ConvertApiPrfType2VppType(type));
        pCmdBuffer[(*offset)++] = profileIndex<<8;

        retVal = TRUE;

    } else {

        /* Load and select the profile; Since VPP does not provide a mechanism
         * to directly load a profile, first it is copied on to the last entry
         * in a given profile table and and then that entry is selected. Thus
         * the last entry in the given profile table is overwritten */

        /* Make sure the profile is same as what it says it is */
        if(useProfileTable == FALSE) {
            vppPrfType = GET_PROFILE_TYPE(pProfile);
            length = GET_PROFILE_LEN(pProfile);
            if(IsItValidProfile(pProfile, type) == FALSE){
                return FALSE; /* Invalid profile */
            }
        }
        if(type == VP_PROFILE_RING) {
            /* This profile is not supported directly by the device (as
             * seperate tables). Hence processing needs to be done before
             * implementing these. */

            /* Handle both table and pointer requests */
            if(useProfileTable == TRUE) {
                if(pDevObj->pRingingProfileTable[profileIndex] != VP_NULL) {
                    pRingPrf = pDevObj->pRingingProfileTable[profileIndex];
                    /* Store the active profile index */
                    if(broadCast == 1) {
                        for(i = 0; i<VPP_MAX_NUM_LINES; i++){
                            pLineObj =  pDevCtx->pLineCtx[i]->pLineObj;
                            if(pLineObj != VP_NULL){
                                pLineObj->activeRingPrfIndex = profileIndex;
                            }
                        }
                    } else {
                        /* Only one line is being changed */
                        pLineObj =  pDevCtx->pLineCtx[channelId]->pLineObj;
                        pLineObj->activeRingPrfIndex = profileIndex;
                    }
                } else {
                    /* Trying to load a non-existant profile from the table */
                    return FALSE;
                }
            } else {
                /* Use the given profile pointer */
                pRingPrf = pProfile;
                /* Profile pointers are expected to be device (or life
                 * time == that of application) so, store the profile pointer */
                profileIndex = GetProfileTableMaxCount(type) - 1;
                pDevObj->pRingingProfileTable[profileIndex] = pRingPrf;
                if(broadCast == 1) {
                    for(i = 0; i<VPP_MAX_NUM_LINES; i++){
                        pLineObj =  pDevCtx->pLineCtx[i]->pLineObj;
                        if(pLineObj != VP_NULL){
                            pLineObj->activeRingPrfIndex = profileIndex;
                        }
                    }
                } else {
                    /* Only one line is being changed */
                    pLineObj =  pDevCtx->pLineCtx[channelId]->pLineObj;
                    pLineObj->activeRingPrfIndex = profileIndex;
                }
            }

            /* Select appropriate ring candance profile, load reqested channel
             * or all channels */
            for(i=0; i<VPP_MAX_NUM_LINES; i++){
                if(broadCast != 1) {
                    if(channelId != i) {
                        continue; /* Channel specific request and servicing
                                   * some other channel */
                    }
                }

                pLineObj =  pDevCtx->pLineCtx[i]->pLineObj;
                if(pLineObj == VP_NULL) {
                    if(broadCast != 1) {
                        return FALSE; /* Not expected; Since a channel service
                                       * is being requested */
                    } else {
                        continue; /* Skip the channels for whom service is
                                   * required */
                    }
                }
                if(pLineObj->activeRingCadPrfIndex >= 0) {
                    pRingCadPrf = pDevObj->pRingingCadProfileTable[
                                    pLineObj->activeRingCadPrfIndex];  /* Choose
                                    * ring candence profile */
                } else {
                    pRingCadPrf = VP_NULL;
                }
                if(pRingCadPrf == VP_NULL) {
                    /* No cadence profile is used so far; Use a default one */
                    pRingCadPrf = &defaultRingCadencePrf[0];
                }

                retVal = ComposeRingAndCadenceProfile(i, pRingPrf, pRingCadPrf,
                                                    pCmdBuffer, offset);
                if(retVal != TRUE) {
                    return retVal;
                }
            }
        } else if(type == VP_PROFILE_RINGCAD) {
            /* This profile is not supported directly by the device (as seperate
             * tables). Hence processing needs to be done before implementing
             * these. */

            /* User wants to change Ringing cadence profile; Handle both table
             * and pointer requests */
            if(useProfileTable == TRUE) {
                if(pDevObj->pRingingCadProfileTable[profileIndex] != VP_NULL) {
                    pRingCadPrf = pDevObj->pRingingCadProfileTable[
                                    profileIndex];
                    /* Store the active profile index */
                    if(broadCast == 1) {
                        for(i = 0; i<VPP_MAX_NUM_LINES; i++){
                            pLineObj =  pDevCtx->pLineCtx[i]->pLineObj;
                            if(pLineObj != VP_NULL){
                                pLineObj->activeRingCadPrfIndex = profileIndex;
                            }
                        }
                    } else {
                        /* Only one line is being changed */
                        pLineObj =  pDevCtx->pLineCtx[channelId]->pLineObj;
                        pLineObj->activeRingCadPrfIndex = profileIndex;
                    }
                } else {
                    /* Trying to load a non-exitant profile from the table */
                    return FALSE;
                }
            } else {
                /* Use the given profile pointer */
                pRingCadPrf = pProfile;
                /* Profile pointers are expected to be device (or life time ==
                 * that of application) so, store the profile pointer */
                profileIndex = GetProfileTableMaxCount(type) - 1;
                pDevObj->pRingingCadProfileTable[profileIndex] = pRingCadPrf;
                if(broadCast == 1) {
                    for(i = 0; i<VPP_MAX_NUM_LINES; i++){
                        pLineObj =  pDevCtx->pLineCtx[i]->pLineObj;
                        if(pLineObj != VP_NULL){
                            pLineObj->activeRingCadPrfIndex = profileIndex;
                        }
                    }
                } else {
                    /* Only one line is being changed */
                    pLineObj =  pDevCtx->pLineCtx[channelId]->pLineObj;
                    pLineObj->activeRingCadPrfIndex = profileIndex;
                }
            }

            /* Select appropriate ring profile, load reqested channel or
             * all channels */
            for(i=0; i<VPP_MAX_NUM_LINES; i++){
                if(broadCast != 1) {
                    if(channelId != i) {
                        continue; /* Channel specific request and servicing
                                   * some other channel */
                    }
                }

                pLineObj =  pDevCtx->pLineCtx[i]->pLineObj;
                if(pLineObj == VP_NULL) {
                    if(broadCast != 1) {
                        return FALSE; /* Not expected; Since a channel
                                       * service is being requested */
                    } else {
                        continue; /* Skip the channels for whom service is
                                   * required */
                    }
                }
                if(pLineObj->activeRingPrfIndex >= 0) {
                    pRingPrf =  pDevObj->pRingingProfileTable[
                                pLineObj->activeRingPrfIndex]; /* Choose
                                      * ring profile */
                } else {
                    pRingPrf =  VP_NULL;
                }
                if(pRingPrf == VP_NULL) {
                    /* No ring profile is used so far; Use a default one */
                    pRingPrf = &defaultRingPrf[0];
                }

                retVal = ComposeRingAndCadenceProfile(i, pRingPrf, pRingCadPrf,
                                pCmdBuffer, offset);
                if(retVal != TRUE) {
                    return retVal;
                }
            }
        } else { /* All other profiles */

            if(*offset + 3 + length >= VPP_CMD_PAGE_MAX_LEN) { /* Set Profile +
                * Select profile cmd (1 + 2 word)  */
                #ifdef DEBUG_VPP_API
                term_printf("ERROR: Not enough space to write the profile\n");
                #endif /* DEBUG_VPP_API */
                return FALSE; /* Not enough space to write Set profile +
                               * Select profile command */
            }

            profileIndex = GetProfileTableMaxCount(type) - 1; /* Use the last
            * slot in the profile table */

            /* Compose the profile set command */
            pCmdBuffer[(*offset)++] = VPP_SET_PRF_CMD(vppPrfType);
            pCmdBuffer[(*offset)++] = (profileIndex<<8) + length;
            ConvertAndAppendPrfData(&pProfile[4], length, pCmdBuffer, offset);

            /* This function is being called to load and select the profile */
            /* Compose the profile select command */
            if(type != VP_PROFILE_CID) {
                /* Since there is only one entry for CID profile, Select
                 * CID profile is not necessary */
                pCmdBuffer[(*offset)++] = VPP_SELECT_PRF_CMD(broadCast,
                                            channelId, vppPrfType);
                pCmdBuffer[(*offset)++] = profileIndex<<8;
            }

            retVal = TRUE;
        }
    }
    return retVal;
} /* GenerateMailBoxProfile() */


/*
 * ComposeRingAndCadenceProfile()
 * This function combines given ringing profile and ringing cadence profile and
 * stores the result in the given buffer.
 *
 * Preconditions:
 * The temporary buffer that is passed to this function is assumed to have
 * enough storage room to store the HBI command. The start index from where
 * the generated command needs to be stroed needs to be passed to this function.
 *
 * Postconditions:
 * If the function completes successfully, then it returns TRUE and stores the
 * necessary commands to store the profile to the part. It also updates the
 * length of the buffer after storing the profile command.
 */
static bool
ComposeRingAndCadenceProfile(
    uint8 channelId,
    VpProfilePtrType pRingPrf,
    VpProfilePtrType pRingCadPrf,
    uint16 *pCmdBuffer,
    uint8 *offset)
{
    uint8 length;
    bool broadCast = 0;

    if((channelId >= VPP_MAX_NUM_LINES) && (channelId != VP_ALL_LINES)){
       /* Not a supported channel */
       return FALSE;
    }
    if(channelId == VP_ALL_LINES) {
        broadCast = 1;
        channelId = 0;
    }

    length = GET_PROFILE_LEN(pRingPrf) + GET_CAD_PROFILE_LEN(pRingCadPrf) + 2;
    if(*offset + 3 + length >= VPP_CMD_PAGE_MAX_LEN) { /* Set Profile +
        * Select profile cmd (1 + 2 word)  */
        #ifdef DEBUG_VPP_API_PROFILE
        term_printf("ERROR: Not enough space to write the profile\n");
        #endif /* DEBUG_VPP_API_PROFILE */
        return FALSE; /* Not enough space to write Set profile +
                       * Select profile command */
    }

    /* Compose the profile set command */
    pCmdBuffer[(*offset)++] = VPP_SET_PRF_CMD(VPP_PROFILE_RING_AND_CAD);
    pCmdBuffer[(*offset)++] = (channelId<<8) + length; /* Use profile
     * indexes that are different for each channel;
     * Need to do this because VPP might not copy the content
     * but may refer to it when needed; Thus if we want different
     * functionality for each line we need to make use of different profile
     * indexes */
    ConvertAndAppendPrfData(&pRingPrf[4], GET_PROFILE_LEN(pRingPrf),
                                pCmdBuffer, offset); /* Ring Profile */
    ConvertAndAppendPrfData(&pRingCadPrf[6], GET_CAD_PROFILE_LEN(pRingCadPrf)+2,
                                pCmdBuffer, offset); /* Ring Candence profile */

    /* This function is being called to load and select the profile */
    /* Compose the profile select command */
    pCmdBuffer[(*offset)++] =
        VPP_SELECT_PRF_CMD(broadCast, channelId, VPP_PROFILE_RING_AND_CAD);
    pCmdBuffer[(*offset)++] = (channelId<<8);   /* Channel specific profile */

    return TRUE;
} /* ComposeRingAndCadenceProfile() */


/*
 * AddProfileData()
 * This function converts 8-bit data to 16bit data and appends them to the
 * given destination data pointer.
 *
 * Preconditions:
 * Assumes there is enough spance in the destination pointer.
 *
 * Postconditions:
 * Given data is compressed and appended to the destination.
 * Also the offset where the next free space is available in the
 * destination pointer is also updated.
 */
static void         /* Returns true if the data was added successfully */
ConvertAndAppendPrfData(
    const VpProfilePtrType pSrcPrf,/* Profile Source pointer */
    const uint8 length,            /* Number of bytes that need to be added
                                    * (should be always even)*/
    uint16 *destPrfPtr,            /* Profile destination pointer */
    uint8 *offset)                 /* Pointer to the location which contains
                                    * offset from where the data data needs to
                                    * be added */
{
    int i;

    for(i=0; i<length; i = i+2){
        destPrfPtr[(*offset)++] = (uint16)((pSrcPrf[i]<<8) + pSrcPrf[i+1]);
    }
} /* AddProfileData() */


/*
 * GetProfileTableMaxCount()
 * This function returns the maximum index permitted for a given type of
 * profile table.
 *
 * Preconditions
 * None.
 *
 * Postconditions
 * None.
 */
static uint8
GetProfileTableMaxCount(
    const VpProfileType profileType)
{
    switch (profileType) {
        case VP_PROFILE_DEVICE:         {return VPP_DEV_PROF_MAX_CNT; }
        case VP_PROFILE_AC:             {return VPP_AC_PROF_MAX_CNT;  }
        case VP_PROFILE_DC:             {return VPP_DC_PROF_MAX_CNT;  }
        case VP_PROFILE_RING:           {return VPP_RING_PROF_MAX_CNT;}
        case VP_PROFILE_RINGCAD:        {return VPP_RINGCAD_PROF_MAX_CNT;}
        case VP_PROFILE_TONE:           {return VPP_TONE_PROF_MAX_CNT;}
        case VP_PROFILE_TONECAD:        {return VPP_TONECAD_PROF_MAX_CNT;}
        case VP_PROFILE_METER:          {return VPP_MTR_PROF_MAX_CNT; }
        case VP_PROFILE_CID:            {return VPP_CID_TYPE1_PROF_MAX_CNT; }/*
           * VPP-API has two entries in the profile table
           * for CID profile. However these two entries are
           * differentiated based on the profile type inside
           * the profile and are always stored in index 0 of the
           * device Type 1 and Type 2 profiles. */
        case VP_PROFILE_TEST_CRITERIA:  {return VPP_TEST_SETUP_PROF_MAX_CNT; }
        case VP_PROFILE_TEST_TOPOLOGY:  {return VPP_TEST_TOPOLOGY_PROF_MAX_CNT;}
        /* Other profile types are not supported by VPP */
        default: return 0;
    }
} /* GetProfileTableMaxCount() */

/*
 * ConvertApiPrfType2VppType()
 * This function converts from API profile types to VPP device specific profile
 * types
 *
 * Preconditions:
 * Assumes this function is called with only those profile types that are
 * supported by the VPP.
 *
 * Postconditions:
 * None
 */
static VppProfileType
ConvertApiPrfType2VppType(
    const VpProfileType type)   /* Profile to be converted */
{
    switch (type) {
        case VP_PROFILE_AC:             return VPP_PROFILE_AC;
        case VP_PROFILE_DC:             return VPP_PROFILE_DC;
        case VP_PROFILE_RING:           return VPP_PROFILE_RING_AND_CAD;
        case VP_PROFILE_RINGCAD:        return VPP_PROFILE_RING_AND_CAD;
        case VP_PROFILE_TONE:           return VPP_PROFILE_TONE;
        case VP_PROFILE_METER:          return VPP_PROFILE_METER;
        case VP_PROFILE_CID:            return VPP_PROFILE_CID_TYPE1; /*
                                               * DevNotes: Is this correct ? */
        case VP_PROFILE_TONECAD:        return VPP_PROFILE_TONECAD;
        case VP_PROFILE_TEST_CRITERIA:  return VPP_PROFILE_TEST_CRITERIA;
        case VP_PROFILE_TEST_TOPOLOGY:  return VPP_PROFILE_TEST_TOPOLOGY;
        default:                        return -1;
    }
    return VP_NUM_PROFILE_TYPES;
} /* ConvertApiPrfType2VppType() */

/*
 * IsItValidProfile()
 * This function performs basic profile error checking
 *
 * Preconditions:
 * None
 *
 * Postconditions:
 * None
 */
static bool /* returns TRUE if given profile is valid */
IsItValidProfile(
    const VpProfilePtrType pProfile,
    const VpProfileType type)
{
    uint8 length;
    VppProfileType vppPrfType;

    length = GET_PROFILE_LEN(pProfile);
    if((length & 1) != 0) {
        return FALSE;       /*Incorrect Profile length */
    }

    /* Make sure the profile is same as what it says it is */
    vppPrfType = GET_PROFILE_TYPE(pProfile);
    if( type != ConvertPrfWizPrfType2ApiType(vppPrfType)) {
        return FALSE;
    }

    return TRUE;
} /* IsItValidProfile() */


/*
 * ConvertApiState2VppState()
 * This function converts from API state type to VPP state type.
 *
 * Preconditions:
 * This condition performs no error checking.
 *
 * Postconditions:
 * None
 */
static VppLineStateType
ConvertApiState2VppState(
    const VpLineStateType state)    /* Profile to be converted */
{
    switch (state) {
        case VP_LINE_STANDBY:           return VPP_LINEST_IDLE_LS;
        case VP_LINE_TIP_OPEN:          return VPP_LINEST_IDLE_GS;
        case VP_LINE_ACTIVE:            return VPP_LINEST_ACTIVE;
        case VP_LINE_ACTIVE_POLREV:     return VPP_LINEST_ACTIVE_POLREV;
        case VP_LINE_TALK:              return VPP_LINEST_TALK;
        case VP_LINE_TALK_POLREV:       return VPP_LINEST_TALK_POLREV;
        case VP_LINE_OHT:               return VPP_LINEST_OHT;
        case VP_LINE_OHT_POLREV:        return VPP_LINEST_OHT_POLREV;
        case VP_LINE_DISCONNECT:        return VPP_LINEST_NO_SERVICE;
        case VP_LINE_RINGING:           return VPP_LINEST_RINGING;
        case VP_LINE_RINGING_POLREV:    return VPP_LINEST_RINGING_POLREV;
        default: return -1;
    }

    return VPP_LINEST_NO_SERVICE;
}

/*
 * GenerateReponseMailBoxEvents()
 * This function looks at the response mailbox to determine what type of event
 * needs to be generated. To determine this it looks at response mailbox and
 * determines if the event needs to be consumed by the API itself or it needs
 * to be passed on to the host.
 *
 * Preconditions:
 * This function should only be called if VPP turns back the control of response
 * mailbox.
 *
 * Postconditions:
 * The eventId member of the event that is passed is filled with a nonzero value
 * if the host needs to read the response buffer; If This function does not
 * understand the response mailbox content, it erases the response by handling
 * the control back to VPP.
 */
static VpStatusType
GenerateReponseMailBoxEvents(
    VpDevCtxType *pDevCtx,
    VpEventType *pEvent)
{
    VpVppDeviceObjectType *pDevObj = pDevCtx->pDevObj;
    VpDeviceIdType deviceId = pDevObj->deviceId;

    uint16 resData[2]; /* Get Event never reads the response and by design there
                        * should only be one outstanding response */
    VpStatusType status;
    VppMbCmdIdType cmdResCode;
    uint8 subCmd;
    uint8 channelId;

    /* First initialize the most basic elements of the event */
    pEvent->eventCategory = pEvent->eventId = 0; /* Other elements are
    * presumed to be initalized elsewhere */

    VpSysEnterCritical(deviceId, VP_HBI_CRITICAL_SEC);/* BEGIN CRITICAL
                                                       * SECTION */
    status = AcquireMailBox(deviceId, VPP_HBI_RSPMB_PAGE); /* Note that,
    * since we are not releasing the mail box owner ship if we understand the
    * messgae since it would be done in VpGetResults after reading the results;
    * However if we don't understand the message then we release the mailbox. */
    if(status == VP_STATUS_SUCCESS) {
        /* Read first two words */
        if(VpHbiRd(deviceId, VPP_HBI_RSPMB_PAGE, 0, 1, resData) != TRUE){
            ExitOnHbiError(__func__);
        }
        cmdResCode = (0x0fc0 & resData[1])>>6;
        subCmd = 0x03f & resData[1];
        channelId = (0x7000 & resData[1])>>12;

        switch (cmdResCode) {
            case VPP_CMD_GET_STATUS: {
                if(subCmd == VPP_SCMD_GS_VERSION) {
                    /* Check to see if what response is outstanding */
                    if(pDevObj->bootCompleteProcssing == TRUE){
                        /* The associated command was issued as part of boot
                         * completion to obtain the data for version */
                        pDevObj->bootCompleteProcssing = FALSE;
                        pEvent->eventCategory = VP_EVCAT_RESPONSE;
                        pEvent->eventId = VP_DEV_EVID_BOOT_CMP;
                    } else {
                        pEvent->eventCategory = VP_EVCAT_TEST;
                        pEvent->eventId = VP_DEV_EVID_CHKSUM;
                    }
                } else if(subCmd == VPP_SCMD_GS_LINE_COND) {
                        /* Line conditions in the mailbox; Generate read
                         * complete event */
                        pEvent->eventCategory = VP_EVCAT_RESPONSE;
                        pEvent->eventId = VP_LINE_EVID_RD_LOOP;
                        pEvent->channelId = channelId;
                        pEvent->pLineCtx = pDevCtx->pLineCtx[channelId]; /*
                        * Other elements should be filled */
                } else if(subCmd == VPP_SCMD_GS_PKT_STS) {
                        /* Packet statistics in the mailbox; Generate read
                         * complete event */
                        pEvent->eventCategory = VP_EVCAT_PACKET;
                        pEvent->eventId = VP_LINE_EVID_RD_PKT_STATS;
                        pEvent->channelId = channelId;
                        pEvent->pLineCtx = pDevCtx->pLineCtx[channelId]; /*
                        * Other elements should be filled */
                } else {
                    /* DevNotes: This has to be developed */
                }
                break;
            }
            default: {
                /* Presently code is not developed to handle the response for
                 * this type response from the VPP. Since no event is going to
                 * be generated for this type of response, if the mailbox is
                 * not returned to the host, the response mailbox will lock up
                 * (from future responses; Hence release the mailbox without
                 * reading the response */
                #ifdef DEBUG_VPP_API
                term_printf("ERROR: Do not understand response mailbox content"
                            " = 0x%x; Hence releasing the response buffer "
                            "ownership.",cmdResCode);
                #endif /* DEBUG_VPP_API */
                ReleaseMailBox(deviceId, VPP_HBI_RSPMB_PAGE);
            }
        }
    }

    VpSysExitCritical(deviceId, VP_HBI_CRITICAL_SEC); /* END CRITICAL SECTION */
    return status;
}


/*
 * ReadVersionInfo()
 * This function reads the version information from VPP and formats the
 * contents as per API format.
 *
 * Preconditions:
 * None
 *
 * Postconditions:
 * None
 */
static VpStatusType
ReadVersionInfo(
    VpDeviceIdType deviceId,
    VpChkSumType *pResults)
{
    #define VPP_SCMD_GS_VERSION_LEN         3
    uint16 responseBuf[VPP_SCMD_GS_VERSION_LEN];
    VpStatusType  status;

    status = ReadResponseMb(deviceId, VPP_SCMD_GS_VERSION_LEN -1 , responseBuf);
    if(status == VP_STATUS_SUCCESS) {
        pResults->loadChecksum = 0; /* Since VPP does not provide checksum
                                     * information */
        pResults->vInfo.vtdRevCode = responseBuf[2];
        pResults->vInfo.swProductId = 0;
        pResults->vInfo.swVerMajor = (0xff00 & responseBuf[1]) >> 8;
        pResults->vInfo.swVerMinor = 0x00ff & responseBuf[1];
    }

    return status;
} /* ReadVersionInfo() */

/*
 * ReadLineCond()
 * This function reads the loop conditions from the response mailbox.
 *
 * Preconditions:
 * None
 *
 * Postconditions:
 * None
 */
static VpStatusType
ReadLineCond(
    VpDeviceIdType deviceId,
    VpLoopCondResultsType *pResults)
{
    #define TOTAL_LINE_COND_RES_LEN (VPP_GETSTS_LINE_COND_RSP_LEN + 1 + \
                VPP_GETSTS_BAT_VOLT_RSP_LEN + 1)

    uint16 responseBuf[TOTAL_LINE_COND_RES_LEN];
    VpStatusType  status;

    status = ReadResponseMb(deviceId, TOTAL_LINE_COND_RES_LEN - 1, responseBuf);
    if(status == VP_STATUS_SUCCESS) {
        pResults->ilg = responseBuf[1];
        pResults->imt = responseBuf[2];
        pResults->vsab = responseBuf[3];
        pResults->rloop = responseBuf[4];

        /* Response from the battery voltage read command */
        pResults->vbat2 = responseBuf[6]; /* Skip the command itself */
        pResults->vbat1 = responseBuf[7];
        pResults->vbat3 = responseBuf[8];
    }

    return status;
} /* ReadLineCond() */

/*
 * ReadVersionInfo()
 * This function reads the packet statistics information from VPP and formats
 * the contents as per API format.
 *
 * Preconditions:
 * None
 *
 * Postconditions:
 * None
 */
static VpStatusType
ReadPktStatistics(
    VpDeviceIdType deviceId,
    VpPacketStatisticsType *pResults)
{
    #define VPP_SCMD_GS_PKT_STS_LEN     (VPP_GETSTS_PKT_STATIS_RSP_LEN + 1)
    uint16 responseBuf[VPP_SCMD_GS_PKT_STS_LEN];
    VpStatusType  status;

    status = ReadResponseMb(deviceId, VPP_SCMD_GS_PKT_STS_LEN -1 , responseBuf);
    if(status == VP_STATUS_SUCCESS) {
        /* The first two words of the response contain, length +
         * command itself */
        pResults->totalUsReadPkts = (responseBuf[1]<<16) + responseBuf[2];
        pResults->totalUsLostPkts = (responseBuf[3]<<16) + responseBuf[4];
        pResults->totalDsExpectedPkts = (responseBuf[5]<<16) + responseBuf[6];
        pResults->totalDsLostPkts = (responseBuf[7]<<16) + responseBuf[8];
    }

    return status;
} /* ReadPktStatistics() */


/*
 * AcquireMailBox()
 * This function acquires (in other words checks to see if the host can
 * make use of the mailbox) the requested mailbox ownership for the Host.
 *
 * Preconditions:
 * This function must be called within critical section; This function
 * is NOT protected by the crtical section enter/exit functions.
 *
 * Postconditions:
 * Returns status after it tries to acquire the mailbox if the function is
 * successfull in acquiring the requested resource.
 */
static VpStatusType
AcquireMailBox(
    const VpDeviceIdType deviceId,
    const VppHbiPageId pageMailBox) /* VPP Mail Box to be acquired */
{
    uint16 mailBoxFlag;

    #ifdef WAIT_TO_ACQUIRE_VPP_MB
    uint32 i;
    /* Acquire mailbox */
    /* In most cases, the a given mailBox should be readily available when asked
     * for by the host. If there are cases when the mailbox is not available
     * (like command mailbox; due to VPP still processing commands, it might be
     * worthwhile to wait for the mail box instead of returning a mailbox busy
     * error.  */
    for(i=0; i<ITERATIONS_TO_WAIT_FOR_VPP_MB; i++) {
        if(VpHbiRd(deviceId, HW_Reg_MBOXFLAG, &mailBoxFlag) == FALSE){
            ExitOnHbiError(__func__);
        }
        if((mailBoxFlag & (1<<pageMailBox)) > 0) {   /* If host 'owns' mbox */
            if((pageMailBox == VPP_HBI_CH1DS_PAGE) ||
               (pageMailBox == VPP_HBI_CH2DS_PAGE) ||
               (pageMailBox == VPP_HBI_CH12DS_PAGE) ||
               (pageMailBox == VPP_HBI_CH22DS_PAGE)){
                /* Instead of waiting for mailbox, accept packet loss!! */
                #ifdef DEBUG_VPP_API
                term_printf("WARNING: DS Packet Window Missed!, MB = %d\n",
                            pageMailBox);
                #endif /* DEBUG_VPP_API */
                return VP_STATUS_MAILBOX_BUSY;
            }
            if((pageMailBox == VPP_HBI_CH1US_PAGE) ||
               (pageMailBox == VPP_HBI_CH2US_PAGE) ||
               (pageMailBox == VPP_HBI_CH12US_PAGE) ||
               (pageMailBox == VPP_HBI_CH22US_PAGE)){
                /* Instead of waiting for mailbox, accept packet loss!! */
                #ifdef DEBUG_VPP_API
                term_printf("WARNING: US Packet Window Missed!, MB = %d\n",
                            pageMailBox);
                #endif /* DEBUG_VPP_API */
                return VP_STATUS_MAILBOX_BUSY;
            }
            #ifdef DEBUG_VPP_API
            if((i % 10) == 9 ) {
                term_printf("WARNING: Waiting for VPP mailbox %d, %ld\n",
                                pageMailBox, i);
            }
            #endif /* DEBUG_VPP_API */
        } else {
            #ifdef DEBUG_VPP_API_MAILBOX
            term_printf("Obtained Mailbox for VPP mailbox\n");
            #endif /* DEBUG_VPP_API_MAILBOX */
            return VP_STATUS_SUCCESS;
        }
    }
    return VP_STATUS_MAILBOX_BUSY;
    #else

    if(VpHbiRd(deviceId, HW_Reg_MBOXFLAG, &mailBoxFlag) == FALSE){
        ExitOnHbiError(__func__);
    }
    if((mailBoxFlag & (1<<pageMailBox)) == 0){
        return VP_STATUS_SUCCESS;
    } else {
        return VP_STATUS_MAILBOX_BUSY;  /* VPP owns the mailbox */
    }
    #endif  /* WAIT_TO_ACQUIRE_VPP_MB */
} /* AcquireMailBox() */

/*
 * ReleaseMailBox()
 * This function release (in other passes on the ownership of the mailbox
 * to the VPP) the requested mailbox ownership for the VPP.
 *
 * Preconditions:
 * This function must be called within critical section; This function
 * is NOT protected by the crtical section enter/exit functions.
 *
 * Postconditions:
 * Releases the requested mailbox ownership to the VPP.
 */
static VpStatusType
ReleaseMailBox(
    const VpDeviceIdType deviceId,
    const VppHbiPageId pageMailBox) /* VPP Mail Box to be acquired */
{
    uint16 mailBoxFlag = 1<<pageMailBox;
    if(VpHbiWr(deviceId, HW_Reg_MBOXFLAG, &mailBoxFlag) == FALSE){
        ExitOnHbiError(__func__);
    }
    #ifdef DEBUG_VPP_API_MAILBOX
    term_printf("Release Mailbox for VPP mailbox\n");
    #endif /* DEBUG_VPP_API_MAILBOX */
    return VP_STATUS_SUCCESS;
} /* ReleaseMailBox() */

/*
 * IssueHbiCommandNoCritical()
 * This function issues raw HBI commands (one or more HBI application
 * level commands) to VPP by acquiring VPP command  mailbox, writing the
 * command and then releasing the mailbox. Note that this function always
 * starts from the top of the command mailbox.
 *
 * Preconditions:
 * This funciton is not critical section protected. Hence The caller
 * of this function must function must ensure that this function
 * is called from critical section.
 *
 * Postconditions:
 * Returns failure or success vector
 */
static VpStatusType
IssueHbiCommandNoCritical(
    const VpDeviceIdType deviceId,
    uint16 *cmdBuf, /* Command/Data buffer */
    const uint16 length)    /* Length (one less) to be written to VPP */
{
    VpStatusType status;
    int i;

    /* Acquire mailbox; Copy the commands and release the mailbox */
    if((status = AcquireMailBox(deviceId, VPP_HBI_CMDMB_PAGE)) ==
            VP_STATUS_SUCCESS) {
        /* Now write the Set State commands */
        if(!VpHbiWr(deviceId, VPP_HBI_CMDMB_PAGE, 0, length, cmdBuf)){
            status = VP_STATUS_ERR_HBI;
        } else {
            status = ReleaseMailBox(deviceId, VPP_HBI_CMDMB_PAGE);
        }
    }

    #ifdef DEBUG_VPP_API
    term_printf("[[HBI CMD]]: ");
    for(i = 0; i < (length+1); i++) {
        term_printf("0x%.4x ", cmdBuf[i]);
    }
    term_printf("\n");
    #endif /* DEBUG_VPP_API */

    return status;
} /* IssueHbiCommandNoCritical() */

/*
 * IssueHbiCommand()
 * This function issues raw HBI commands (one or more HBI application
 * level commands) to VPP by acquiring VPP command  mailbox, writing the
 * command and then releasing the mailbox. Note that this function always
 * starts from the top of the command mailbox.
 *
 * Preconditions:
 * This funciton is Protected with critical sections. Hence it is not
 * necessary to protect this function with such mechanisms by the calling
 * function.
 *
 * Postconditions:
 * Returns failure or success vector
 */
static VpStatusType
IssueHbiCommand(
    const VpDeviceIdType deviceId,
    uint16 *cmdBuf,         /* Command/Data buffer */
    const uint16 length)    /* Length (one less) to be written to VPP */
{
    VpStatusType status;

    VpSysEnterCritical(deviceId, VP_HBI_CRITICAL_SEC);/* BEGIN CRITICAL
                                                       * SECTION */

    status = IssueHbiCommandNoCritical(deviceId, cmdBuf, length);

    VpSysExitCritical(deviceId, VP_HBI_CRITICAL_SEC); /* END CRITICAL SECTION */

    return status;
} /* IssueHbiCommand() */

/*
 * ReadResponseMb()
 * This function reads a response from the response mailbox. This function
 * does not understand the format of the message. It just obtains the mailbox
 * and reads the content and releases the mailbox.
 *
 * Preconditions:
 * None
 *
 * Postconditions:
 * None
 */
static VpStatusType
ReadResponseMb(
    VpDeviceIdType deviceId,
    uint8 length,       /* Length - 1 words to be read */
    uint16 *pDataBuf)
{
    VpStatusType status;
    int i;

    VpSysEnterCritical(deviceId, VP_HBI_CRITICAL_SEC);/* BEGIN CRITICAL
                                                       * SECTION */

    /* Acquire mailbox; Copy the commands and release the mailbox */
    if((status = AcquireMailBox(deviceId, VPP_HBI_RSPMB_PAGE)) ==
                VP_STATUS_SUCCESS) {
        /* Response first word is always length of all the responses */
        if(!VpHbiRd(deviceId, VPP_HBI_RSPMB_PAGE, 1,  length, pDataBuf)){
            ExitOnHbiError(__func__);
        } else {
            status = ReleaseMailBox(deviceId, VPP_HBI_RSPMB_PAGE);
        }
        #ifdef DEBUG_VPP_API
        term_printf("Read Response: ");
        for(i=0; i<=length; i++) {
            term_printf("0x%.4x ", pDataBuf[i]);
        }
        term_printf("\n");
        #endif /* DEBUG_VPP_API */
    }

    VpSysExitCritical(deviceId, VP_HBI_CRITICAL_SEC); /* END CRITICAL SECTION */

    return status;
} /* ReadResponseMb() */


/*
 * SetDefaultMasks()
 * This function configures the default event masks for VPP class of devices.
 * It also configures default ownership of mailbox
 *
 * Preconditions:
 * This function assumes the device has been bootloaded.
 * This function does not call HAL layer functions within critical sections.
 *
 * Postconditions:
 * Configures default event masks.
 */
static void SetDefaultMasks(
    VpDeviceIdType deviceId)
{
    /* Default masks */
    #define DEFAULT_SYSTEM_INT_MASK         0x0f1f
    #define DEFAULT_MAILBOX_EVENT_MASK      0xfc00  /* DevNotes: Presently
    * packet mail box event is disabled 0xffc0 */
    #define DEFAULT_DEVICE_EVENT_MASK       0xfff7
    #define DEFAULT_CHANNEL_EVENT_MASK      0x6200 /* DevNotes: need to be
    * changed later 0x6200 */

    uint16 dataRd;
    uint16 wrData;

    /* Setup MailBox Flags */
    if(!VpHbiRd(deviceId, HW_Reg_MBOXFLAG, &dataRd)){
        ExitOnHbiError(__func__);
    }
    #ifdef DEBUG_VPP_API
    term_printf("Mail Box Flag Rd: 0x%.4x\n", dataRd);
    #endif /* DEBUG_VPP_API */

    /* Setup System Interrupt Mask */
    wrData = DEFAULT_SYSTEM_INT_MASK;
    #ifdef DEBUG_VPP_API
    if(!VpHbiRd(deviceId, HW_Reg_SYSINTMASK, &dataRd)){
        ExitOnHbiError(__func__);
    }
    term_printf("System Int Mask: Rd = 0x%.4x, Wr = 0x%.4x\n", dataRd, wrData);
    #endif /* DEBUG_VPP_API */
    if(!VpHbiWr(deviceId, HW_Reg_SYSINTMASK, &wrData)){
        ExitOnHbiError(__func__);
    }

    /* MailBox Event Mask */
    wrData = DEFAULT_MAILBOX_EVENT_MASK;
    #ifdef DEBUG_VPP_API
    if(!VpHbiRd(deviceId, VPP_Reg_MAILBOX_MASK, &dataRd)){
        ExitOnHbiError(__func__);
    }
    term_printf("MailBox Event Mask: Rd = 0x%.4x, Wr = 0x%.4x\n", dataRd,
                    wrData);
    #endif /* DEBUG_VPP_API */
    if(!VpHbiWr(deviceId, VPP_Reg_MAILBOX_MASK, &wrData)){
        ExitOnHbiError(__func__);
    }

    /* Device Event Mask */
    wrData = DEFAULT_DEVICE_EVENT_MASK;
    #ifdef DEBUG_VPP_API
    if(!VpHbiRd(deviceId, VPP_Reg_DEVICE_EVENT_MASK, &dataRd)){
        ExitOnHbiError(__func__);
    }
    term_printf("Device Event Mask: Rd = 0x%.4x, Wr = 0x%.4x\n", dataRd,
                    wrData);
    #endif /* DEBUG_VPP_API */
    if(!VpHbiWr(deviceId, VPP_Reg_DEVICE_EVENT_MASK, &wrData)){
        ExitOnHbiError(__func__);
    }

    /* Channel Event Mask */
    wrData = DEFAULT_CHANNEL_EVENT_MASK;
    #ifdef DEBUG_VPP_API
    if(!VpHbiRd(deviceId, VPP_Reg_CHNL_0_EVENT_MASK, &dataRd)){
        ExitOnHbiError(__func__);
    }
    term_printf("Channel 0 Event Mask: Rd = 0x%.4x, Wr = 0x%.4x\n", dataRd,
                    wrData);
    #endif /* DEBUG_VPP_API */
    if(!VpHbiWr(deviceId, VPP_Reg_CHNL_0_EVENT_MASK, &wrData)){
        ExitOnHbiError(__func__);
    }
    #ifdef DEBUG_VPP_API
    if(!VpHbiRd(deviceId, VPP_Reg_CHNL_1_EVENT_MASK, &dataRd)){
        ExitOnHbiError(__func__);
    }
    term_printf("Channel 1 Event Mask: Rd = 0x%.4x, Wr = 0x%.4x\n", dataRd,
                    wrData);
    #endif /* DEBUG_VPP_API */
    if(!VpHbiWr(deviceId, VPP_Reg_CHNL_1_EVENT_MASK, &wrData)){
        ExitOnHbiError(__func__);
    }

} /* SetDefaultMasks() */

/*
 * ExitOnHbiError()
 * This function exits the application upon an HBI error
 *
 * Preconditions:
 * None
 *
 * Postconditions:
 * None
 */
static void ExitOnHbiError(
    char *data)     /* data string to be printed */
{
    #ifdef DEBUG_VPP_API
    term_printf("\nERROR: HBI access error in function %s\n", data);
    #endif /* DEBUG_VPP_API */

    #ifdef EXIT_ON_VPP_HBI_ACCESS_ERROR
    exit(1);
    #endif /* EXIT_ON_VPP_HBI_ACCESS_ERROR */
} /* ExitOnHbiError */


#endif /* (VP_CC_VPP_SERIES) */




