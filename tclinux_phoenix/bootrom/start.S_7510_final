        
#include <asm/asm.h>
#include <asm/regdef.h>
#include <asm/mipsregs.h>        

#define	CR_ARB_BASE			0xBFB00000
#define	CR_TIMER_BASE			0xBFBF0100
#define	GPIOBASE			0xBFBF0200
#define	CR_SMC_BASE			0xBFB10000
#define	CR_DMC_BASE			0xBFB20000
#define	ROUND_ROBIN_ARBITER	1

// delay BUS clock
#define DLY_CLK_CYCLE(cyc) \
		li	t0, cyc; \
		srl	t0, t0, 1; \
999:	subu	t0, t0, 1; \
		bgtz	t0, 999b; \
		nop

// 16-bit SDRAM or not
#define SDRAM16          	1 
// CAS 2T or 3T
//#define CAS_2T            1
// 16MB size SDRAM or not
//#define SDRAM_16M        	1

/* TC3262 speicific configuration */
//#define UNCACHE_MODE
//#define DEBUG 1

#if 1

#define DISPLAYLED(d0,d1) 	nop

#else

#define DISPLAYLED(d0,d1) \
    la v0, GPIOBASE; \
    li t5, d0; \
	li t6, d1; \
	sw t5, 0x4(v0); \
2:  addi t6, -1; \
	bnez t6, 2b;\
	nop; \
	nop

#endif
					 
        .text
        .set noreorder
		.globl __start              
__start:
		j	boot_start
		nop

header_start:
		nop
		nop
		nop
		nop
		nop						// for boot_start address
		nop						// for boot_end	address
		nop						// for lzma_start address
		nop						// for lzma_end address

boot_start:
#ifdef TC3262
#ifdef DEBUG

		jal sys_uart_init
                nop


                li t7, 'x'
                jal disp_character
                nop
#endif
		/* Clear watch registers */
		mtc0	zero, CP0_WATCHLO
		mtc0	zero, CP0_WATCHHI

		/* Check whether NMI happen */
		mfc0   	k0, CP0_STATUS
		srl		k1, k0, (S_StatusNMI)   
		andi		k1, 0x1
		beqz		k1, no_nmi
		nop

		la		k0,	0xbfb00244	/*NMI happen, read NMI handler address, then jump to it*/
		lw		k1, 0x0(k0)
		nop
		jr		k1
		nop
		
no_nmi:
		/* Disable interrupts and KSU field (power up issue) */
		mfc0   	k0, CP0_STATUS
		li		k1, ~(M_StatusIE | M_StatusKSU)
		and		k0, k1
		mtc0	k0, CP0_STATUS

		/* Setup cause register (clear cause code)  */
		li		k0, M_CauseIV
		mtc0	k0, CP0_CAUSE
#ifdef DEBUG
		li t7, 'a'
                jal disp_character
                nop

#endif
		/* Set CPU clock */
		jal 	sys_init_cpuclk
		nop
#ifdef DEBUG
                li t7, 'b'
                jal disp_character
                nop

#endif

		/* Perform CPU specific initialisation */
		jal     sys_init_processor
		nop
#ifdef DEBUG
                li t7, 'c'
                jal disp_character
                nop

#endif
#ifdef SIS_DDR_PHY
                la		k0,	CR_ARB_BASE
		lw		k1, 0x64(k0)
		nop
		srl		k1, k1, 16
		sub 	k1,	3							/* check if RT63165 */
		#ifndef MT75XX_REDUCE_SIZE
		bltz   	k1, sis_ddr_init
		nop
		#endif

		sub		k1, 2	// MT7510 FPGA temporary ID is 0x5
		beqz	k1, mtk_dmc_init
		nop

		#ifndef MT75XX_REDUCE_SIZE

		/* RT63165 */
		jal		sys_init_dmc
		nop
		j		sis_ddr_exit	
		nop
		#endif

mtk_dmc_init:

		la      k0, CR_ARB_BASE
		la      k1, 0x00750025
		sw      k1, 0x39c(k0)
		lw      k1, 0x378(k0)
		nop
		li      t0,0xff0fffff
		and     k1, k1,t0
		nop
		li      t0,0xd01000
		or 		k1, k1,t0
		sw  	k1, 0x378(k0)

		jal sys_init_mtk_dmc
		nop
		j	sis_ddr_exit
		nop

		#ifndef MT75XX_REDUCE_SIZE
sis_ddr_init:
		/* TC3182/TC3262 */
		jal		sys_init_ddr					/* Init DDR controller */
		nop
		#endif
sis_ddr_exit:

#endif

		/*  Initialise caches. If compiled for simulation, we
	 	 *  skip this since caches can be assumed to be invalidated.
	 	 */
		jal     sys_init_cache
		nop
#endif

#ifdef DDR_CALI
#ifdef DEBUG
                li t7, 'd'
                jal disp_character
                nop

#endif
		/*run ddr calibration in IMEM/DMEM
		*/
#define HW_CONFIG2		0xf8
#define	SCREG_WR0		0x280
#define	DSPRAM_PA	0x00017000
#define ISPRAM_PA	0x00018000
#define	DSPRAM_VA	0x80017000
#define ISPRAM_VA	0x80018000
#define ISPRAM_SIZE 0x8000	//32k
#define DSPRAM_SIZE	0x1000 	/*DMEM is 4KB*/

#define SPRAM_MAGIC_NUM 0x32514356		

		//Check spram.bin magic number
		la		t0, __spram_start
		lw		t1, 0(t0)
		nop

		bne		t1, SPRAM_MAGIC_NUM, ddr_calibration_exit
		nop

		//Enable DMEM
		li	a0, DSPRAM_PA
		li	a1, 1
		jal	probe_spram
		nop

		//Enable IMEM
		li	a0, ISPRAM_PA
		li	a1, 3
		jal	probe_spram
		nop

		//Copy instruction to IMEM
		la		t0, __spram_start
		lw		t1, 4(t0)		//Get data section length
		nop

		la	k0, __spram_start
		add	k0, k0, t1
		add k0, k0, 0x10		//Skip spram.bin header
		la	k1, (__spram_end + 4)
		subu	a0, k1, k0		//size of instruction
		subu	a1, k0, 0xa0000000	//start address of instruction
		li	a2, 0
		jal	ispram_fill
		nop

		//Init DMEM
		la	k1, DSPRAM_VA	//Dst address
		li	t1, 0
1:
		sw	zero, 0(k1)	//Init as zero
		nop
		add	k1, k1, 4
		add	t1, t1, 4
		blt	t1, DSPRAM_SIZE, 1b	
		nop
		
		//Copy data to DMEM
		la	t0, __spram_start
		lw	t2, 4(t0)		//Get data section length
		nop

		la	k0, __spram_start
		add	k0, k0, 0x10	//Source address, skip spram.bin header
		la	k1, DSPRAM_VA	//Dst address
		li	t1, 0
1:
		lw	t0, 0(k0)	//Read
		nop
		sw	t0, 0(k1)	//Write
		nop
		add	k1, k1, 4
		add	k0, k0, 4
		add	t1, t1, 4
		blt	t1, t2, 1b	
		nop

		//Save return pc
		la	k1, ddr_calibration_done
		la	k0, CR_ARB_BASE		
		sw	k1, SCREG_WR0(k0)
		
		la	k0, ISPRAM_VA
		jr	k0
		nop

LEAF(ddr_calibration_done)
		//Clear return pc register
		la	k1, 0
		la	k0, CR_ARB_BASE		
		sw	k1, SCREG_WR0(k0)

		//disable ispram
		li	a0, ISPRAM_PA
		li	a1, 2
		jal	probe_spram
		nop

		//diable dspram
		li	a0, DSPRAM_PA
		li	a1, 0
		jal	probe_spram
		nop
END(ddr_calibration_done)
ddr_calibration_exit:
#endif

// configure GPIO4 for dying gasp
		la		v0,		GPIOBASE
		li		a0,		0x00000000
// configure GPIO4 as input
		li		a1,		0x0000
// also set it as open drain
		sw		a0,		0(v0)
		sw		a1,		0x14(v0)
		DISPLAYLED(0x50, 0x1000)

		/* configure arbiter */
	    la	v1,	CR_ARB_BASE
#ifndef TC3262
#ifdef ROUND_ROBIN_ARBITER
	    li	a0,	0x8000ffff		// round robin scheme
	    li	a1,	0x0
#else
	    li	a0,	0x0000ffff
      	li	a1,	0x32107777		// atm > mac > apb > cpu > others
#endif
	    sw	a0,	0x00(v1)
	    sw	a1,	0x04(v1)

#ifdef TC3162L2
        lw      a0,	0xb0(v1)
        nop
		srl		a0, a0, 12
		andi	a0, a0, 0xff
        beqz    a0, tc3162u_pll_exit
        nop   

		/* set TC3162U's PLL */
		li		t1, 0x04631000
		li		t2, 0x18f
		
		//li		t3, 0x18f				/* CPU=266Mhz AHB=133Mhz */
		//li		t3, 0x1c1				/* CPU=300Mhz AHB=150Mhz */
		li		t3, 0x1f3				/* CPU=333Mhz AHB=166Mhz */

		li		t4, 0x1c1					/* when CPU>300MHZ, set PLL gain control */

tc3162u_pll:	
		or		a0, t1, t2
		ble		t2, t4, tc3162u_pll_gain_exit	
		nop
		ori		a0, (1<<15)
tc3162u_pll_gain_exit:	
	    sw		a0,	0xb0(v1)
		nop

// wait 50 us
		li		t0,	5000
1:                              		/* wait 50 us */
		subu 	t0,	1
		bnez	t0,	1b
		nop

    	beq  	t2, t3, tc3162u_pll_exit
    	nop
		addi	t2, t2, 5
		j		tc3162u_pll
		nop

tc3162u_pll_exit:	

#endif

		/* configure DMC bank range */
		/* SDRAM address:	0x80000000 to 0x807fffff  size:	8MB */
#ifdef SDRAM16
#ifdef SDRAM_16M
		li  a0, 0x80000100      // bank0 --> 0000_0000 ~ 00ff_ffff
		li  a1, 0x80000302
		li  a2, 0x80000504
		li  a3, 0x80000706
#else
	#ifdef SDRAM_32M
		li  a0, 0x80000300      // bank0 --> 0000_0000 ~ 01ff_ffff
		li  a1, 0x80000504
		li  a2, 0x80000706
		li  a3, 0x80000908
	#else
		li 	a0,	0x80000000
		li 	a1,	0x80000101      // bank1 --> 0000_0000 ~ 007f_ffff
		li 	a2,	0x80000202
		li 	a3,	0x80000303
	#endif
#endif
#else
		li 	a0,	0x80000000      // bank0 --> 0000_0000 ~ 007f_ffff
		li  a1,	0x80000101
		li  a2,	0x80000202
		li  a3,	0x80000303
#endif
		sw	a0, 0x10(v1)
		sw	a1,	0x14(v1)
		sw	a2,	0x18(v1)
		sw	a3,	0x1c(v1)

		DISPLAYLED(0x51, 0x1000)
#endif

		/* configure SMC */
		/* SRAM address: */
		/*	1. FLASH	 16bit begin at 0x1fc00000 to 0x1fffffff  size:	  4MB */
		/*	2. SRAM    	 8bit begin at 0x1fe00000 to 0x1fe3ffff	size: 256KB   */
		li	a0,	0x80071f1e
		li	a1,	0x00071f1f
		li	a2,	0x00040000

		sw	a0,	0x20(v1)
		sw	a1,	0x24(v1)
#if !defined(TC3162L2) && !defined(TC3262)
		sw	a2,	0x28(v1)
#endif

		DISPLAYLED(0x52, 0x1000)

// SRAM rank 3,4,5
		li	a0,	0x00040808
		li	a1,	0xc0041010	// with bridge				
		li	a2,	0x80050000
#if !defined(TC3162L2) && !defined(TC3262)
		sw	a0,	0x2c(v1)
		sw	a1,	0x30(v1)
#endif
		sw	a2,	0x34(v1)		

		DISPLAYLED(0x54, 0x1000)

    	li	v1,	CR_SMC_BASE
#if defined(TC3162L2) || defined(TC3262)
		li	a0, 0x102d1040    		
#else
		li	a0, 0x102a9040    		
#endif
 		li	a2,	0x10aa8100				/* 16-bit hpi8  configure  */
 		li  a3,	0x200028d0				/* 32-bit dmt   configure  */

		sw	a0,	0x0(v1)      			/* CR_SMC_BANK0     */
//		sw	a1,	0x4(v1)      			/* CR_SMC_BANK1     */
// 		sw	a2,	0x10(v1)     			/* CR_SMC_BANK4     */
 		sw	a3,	0x14(v1)     			/* CR_SMC_BANK5     */

		DISPLAYLED(0x58, 0x1000)

#ifdef TC3262
#ifndef MT75XX_REDUCE_SIZE
	    la		k0,	CR_ARB_BASE
		lw		k1, 0x64(k0)
		nop
		srl		k1, k1, 16
		sub 	k1,	3							/* check if RT63165 */
		bgez   	k1, tc3262_dmc_exit
		nop

		la      v1, CR_ARB_BASE
		lw      s0, 0x8c(v1)
		nop
		srl     s0, s0, 13
		andi    s1, s0, 3               /* DDR memory size */
		srl     s0, s0, 2
		andi    s0, s0, 1               /* DDR1 or DDR2 mode */

		la 		v1, CR_DMC_BASE
		/* set DDR1 or DDR2 mode first */		
		li 		a0, 0x33				/* DDR1 mode */
		la      k0, CR_ARB_BASE			/* Check is rt65168*/
		lw      k1, 0x64(k0)
		nop
		srl     k1, k1, 16
		sub     k1, 2
		bnez    k1, ddr_mode_done
		nop
		beqz    s0, ddr_mode_done
		nop
		li      a0, 0x58000433          /* DDR2 mode */
ddr_mode_done:		
		sw 		a0, 0x78(v1)			/* CAS=3T, Burst type and length=8 */

		lw 		a1, 0x74(v1)			
		li		t0, 0xffe0ffff
		and		a1, a1, t0

#ifdef SDRAM_64M
		li 		a0, 0x20				/* DRAM Size 512 x 16 */
		li 		a2, (0x12<<16)			/* DRAM Size 512 x 16 */
#else
		li 		a0, 0x08				/* DRAM Size 256 x 16 */
		li 		a2, (0xe<<16)			/* DRAM Size 256 x 16 */
#endif

		or 		a1, a1, a2

		sw 		a0, 0x50(v1)			/* Set DRAM size */
		sw 		a1, 0x74(v1)			

#ifndef TC3262_FPGA
#ifndef TCSUPPORT_AUTOBENCH /*SOCKET board can't be enable ddr power saving mode*/
		li		a0, 0x0C600C60			/* DDR control register */
		sw 		a0, 0x100(v1)			
		li		a0, 0xE6E60
		sw 		a0, 0x10c(v1)			
		li		a0, 0xA930200
		sw 		a0, 0x110(v1)			
		li		a0, 0xE6E60
		sw 		a0, 0x114(v1)			
		li		a0, 0x3230c
		sw 		a0, 0x120(v1)
		bnez    k1, ddr_power_done /*check is RT65168*/
		nop
		li		a0, 0x420E7000 /*DDR1 CK DRVP=7 DRVN=7*/
		sw 		a0, 0x104(v1)			
		li		a0, 0x228c8000 /*DDR1 CKE DRVP=8 DRVN=8*/
		sw 		a0, 0x108(v1)

		beqz    s0, ddr_power_done
		nop
		
		li      a0, 0x8400840		/*setting for DDR2*/
		sw      a0, 0x100(v1)
		li	a0, 0x31986000	/*DDR2 CK DRVP=c DRVN=6*/
		sw	a0, 0x104(v1)			
		li      a0, 0x22626100  /*DDR2 CKE DRVP=6 DRVN=6*/
		sw      a0, 0x108(v1)
		li      a0, 0xE4E40
		sw      a0, 0x10c(v1)
		li      a0, 0xE4E40
		sw      a0, 0x114(v1)
		li      a0, 0x70
		sw      a0, 0x118(v1)
		li      a0, 0x2
		sw      a0, 0x7c(v1)

ddr_power_done:		
		
#endif
#endif

		li 		a0, 0xff010001			/* Set master bandwidth control */
		sw 		a0, 0x30(v1)			
		sw 		a0, 0x34(v1)			
		sw 		a0, 0x38(v1)			
		sw 		a0, 0x3c(v1)			
		sw 		a0, 0x40(v1)			
		sw 		a0, 0x44(v1)			
		sw 		a0, 0x48(v1)			

		li 		a0, 0x01
		sw 		a0, 0x58(v1)			/* Enable all bandwidth token counter of DAC */

#ifdef SIS_DDR_PHY
		li		a0, 0x80000000
		li		a1, 0x00000020			/* Test memory size=64byte */
		jal		sys_edqs_scan			/* EDQS scan */
		nop
#endif

tc3262_dmc_exit:
#endif
#else
// init SDRAM
// wait 250 us
		li		a0,	25000
1:                              		/* wait 250 us */
		subu 	a0,	0x01
		bnez	a0,	1b
		nop

		DISPLAYLED(0x5c, 0x20000)
		
		la		v1,	CR_DMC_BASE
#ifdef SDRAM16
    #ifdef CAS_2T
		#ifdef SDRAM_16M
   		li    	a0, 0x00045500    		/* 16bit width, col 9 row 12, 2T CAS Latency (winbond w981216DH-6 16MB)*/
		#else
    	li    	a0,	0x00044400    		/* 16bit width, col 8 row 12, 2T CAS Latency */
		#endif
    #else
		#ifdef SDRAM_16M
    	li    	a0,	0x00e85500    		/* 16bit width, col 9 row 12, 3T CAS Latency */
		#else
		#ifdef SDRAM_32M
    	li    	a0,	0x00e89900    		/* 16bit width, col 9 row 13, 3T CAS Latency */
		#else
		#ifdef SDRAM_2M
    	li    	a0, 0x00e80000    		/* 16bit width, col 8 row 11, 3T CAS Latency */
		#else
    	li    	a0,	0x00e84400    		/* 16bit width, col 8 row 12, 3T CAS Latency */
		#endif
		#endif
		#endif
    #endif
#endif
		sw		a0,	0x00(v1)
#ifdef TC3162L2
		la      k0, CR_ARB_BASE
		li		a0, 0x20
        lw      k1, 0x8c(k0)
		nop		
		srl     k1, k1, 12
		and		k1, k1, 0xff
        /* check if RT63260 */
		bne     k1, a0, 1f
		nop

		li		a0,	0x9
		sb      a0, 0x03(v1)
#ifndef TCSUPPORT_AUTOBENCH
		//set ODSS0[11:10]=00 to fix ethetnet repeat link up. merge from linos.
		lw		a0,	0xb4(k0)
		la		a1,	0xfffff3ff
		and		a0, a0,	a1
		sw	a0,	0xb4(k0)
#endif		

1:
#endif
  		li		a0, 0x02      			/* set TC3162U tRAS=7T */
  		sb		a0, 0x04(v1)

		li		a0,	0x02
		sb		a0,	0x07(v1)     		/* enter precharge all mode */

		la		a1, 0xa0000000
		sw		a1, 0x00(a1)

		li		a0,	0x04
		sb		a0,	0x07(v1)    		/* enter CBR mode */

		li		a0,	0x08
		la		a1,	0xa0000000

		DISPLAYLED(0x58, 0x20000)

1:		                        		/* additional 8 CBR Auto Refresh Cycle */
		sub		a0,	0x01
		sw		a1,	0x00(a1)
		bnez	a0,	1b
		nop

		DISPLAYLED(0x54, 0x20000)

		li		a0,	0x03	    		/* enter MRS mode */
		sb		a0,	0x07(v1)

#ifdef SDRAM16
   	#ifdef CAS_2T
		li 		a1,	0xa0000046    		/* CAS Latency */	
	#else
		li 		a1,	0xa0000066    		/* CAS Latency */	
	#endif
#endif

.set at

		sb		zero,	0x00(a1)

		li		a0,	0x02			    /* enter precharge all mode */
 		sb		a0,	0x07(v1)

.set noat
 
		la		a0,	0xa0000000
		nop

		sb		a1,	0x03(a0)

		DISPLAYLED(0x52, 0x20000)
		
// postive edge
#ifdef TC3162L2
		li		a1,	0x40
		la      k0, CR_ARB_BASE
		li      a0, 0x20
		lw      k1, 0x8c(k0)
		nop
		srl     k1, k1, 12
		and     k1, k1, 0xff
		/* check if RT63260 */
		bne     k1, a0, 1f
		nop     

		li      a1, 0x41 //63260 use post edge
1:		
#else
		li		a1,	0x41
#endif
#ifdef TC3162L2
	#ifdef SDRAM_32M
		li    	a0,	0x34		
	#else
		li    	a0,	0x67		
	#endif
#else
		li    	a0,	0x4e		
#endif

		sb		a1,		0x06(v1)     	/* page mode enable   */
		sb		zero, 	0x07(v1)     	/* normal mode        */
		sb		a0,		0x00(v1)     	/* dram refresh timer */

		nop
		nop
		nop
#endif

		DISPLAYLED(0x51, 0x20000)

		/* stop interrupt */
		li		t0, 	0xbfb40000
		nop

		sw		zero, 	0x0(t0)			/* all interrupt belong to IRQ */
		sw		zero, 	0x04(t0)		/* set all interrupt mask to 0 .. disable all interrupt */

		DISPLAYLED(0x57, 0x20000)

#ifndef TC3262
		li		t0, 0x10400000 			// Initialize the status register
		mtc0	t0, $12
		nop

		//---------------------------------------------------------------------
		// Clear exception cause register
		//---------------------------------------------------------------------
		mtc0	zero, $13
		nop
#endif
#if 0
        /* zero bss */
		move t0, zero
		mtc0 t0, $12
		nop
#endif

#ifdef TC3162L2
		/* imem off */
		mtc0	zero, $20	
		nop
		nop
		li		t0, 0x00000020 
		mtc0	t0, $20
		nop
		nop
		/* dmem off */
		mtc0	zero, $20	
		nop
		nop
		li		t0, 0x00000800 
		mtc0	t0, $20
		nop
		nop
		mtc0	zero, $20
#endif

#ifndef TC3262
		/* flush all cache */
		mtc0	zero, $20
		nop
		nop
		li	t0, 0x3
		mtc0	t0, $20
		nop
		nop
		mtc0	zero, $20
#endif

#ifdef TC3262
#ifndef SIS_DDR_PHY
#ifdef PLL_AUTO_SCAN
		li		a0, 0x80000000
		li		a1, 0x00040000					/* Test memory size=256KB */
		jal		sys_pll_scan
		nop

		move 	t6, v0
		move	a0, v0
		jal 	sys_pll_choose
		nop
		move	t7, v0
		move	t5, v0
#else
		li		t5, PLL_SPSN_VALUE
#endif
		li		v1, CR_DMC_BASE		
		ori     t5,t5,0x100
		sw		t5, 0xb0(v1)	
		nop

1:
		lw		t5, 0xb0(v1)
		and		t5, t5, 0x8000
		bnez    t5, 1b
		nop

		/* save possible pll bitmap and choose pll value */
		li		v1, 0x80020000		
		sw		t6, -4(v1)
		sw		t7, -8(v1)
#endif
#endif
#ifdef DEBUG
                li t7, 'e'
                jal disp_character
                nop

#endif

/* bootloader copression support */
#ifdef LZMA_IMG
		la t0, __boot_start
		la t1, 0x80010000
		sw t0, 0x0(t1)
		la t0, __boot_end
		la t1, 0x80010020
		sw t0, 0x0(t1)

		// Due to this is the bootloader, we prefer not to
		// use stackframe
		// now copy __boot_start to __boot_end
		la	k0, __lzma_start
		la	k1, (__lzma_end + 4)
		la	t1, 0x80000000
#else
		la  k0, __boot_start
		la  k1, (__boot_end + 4)
		la  t1, 0x80000000
#endif

1:
		//DISPLAYLED(0x5c, 0x1000)
		lw	t0, 0(k0)
		nop
		sw	t0, 0(t1)
		//DISPLAYLED(0x50, 0x1000)
		
		addiu k0, k0, 4
		addiu t1, t1, 4
		bne	k1, k0, 1b
		nop
		nop
		nop

#ifdef TC3262

#define S_ConfigK0		0			/* Kseg0 coherency algorithm (R/W) */
#define M_ConfigK0		(0x7 << S_ConfigK0)

#define K_CacheAttrU		2			/* Uncached */

#define SET_MIPS3() .##set mips3
#define SET_MIPS0() .##set mips0
#define SET_PUSH()  .##set push
#define SET_POP()   .##set pop

/* cache operations */

#define CACHE_OP( code, type )			( ((code) << 2) | (type) )

#define ICACHE_INDEX_INVALIDATE			CACHE_OP(0x0, 0)
#define ICACHE_INDEX_LOAD_TAG			CACHE_OP(0x1, 0)
#define ICACHE_INDEX_STORE_TAG			CACHE_OP(0x2, 0)
#define DCACHE_INDEX_WRITEBACK_INVALIDATE	CACHE_OP(0x0, 1)
#define DCACHE_INDEX_LOAD_TAG			CACHE_OP(0x1, 1)
#define DCACHE_INDEX_STORE_TAG			CACHE_OP(0x2, 1)
#define SCACHE_INDEX_WRITEBACK_INVALIDATE	CACHE_OP(0x0, 3)
#define SCACHE_INDEX_STORE_TAG			CACHE_OP(0x2, 3)

#define ICACHE_ADDR_HIT_INVALIDATE		CACHE_OP(0x4, 0)
#define ICACHE_ADDR_FILL			CACHE_OP(0x5, 0)
#define ICACHE_ADDR_FETCH_LOCK			CACHE_OP(0x7, 0)
#define DCACHE_ADDR_HIT_INVALIDATE		CACHE_OP(0x4, 1)
#define DCACHE_ADDR_HIT_WRITEBACK_INVALIDATE	CACHE_OP(0x5, 1)
#define DCACHE_ADDR_HIT_WRITEBACK		CACHE_OP(0x6, 1)
#define DCACHE_ADDR_FETCH_LOCK			CACHE_OP(0x7, 1)

#define SCACHE_ADDR_HIT_WRITEBACK_INVALIDATE	CACHE_OP(0x5, 3)

#define ICACHE_INVALIDATE_WORKAROUND(reg) \
SET_PUSH();				  \
SET_MIPS0();				  \
	la     reg, 999f;		  \
SET_POP();				  \
	cache  ICACHE_ADDR_FILL, 0(reg);  \
	sync;				  \
	nop; nop; nop; nop;		  \
999:

#define ICACHE_ADDR_INVALIDATE_OP(addr,scratch)			  \
	    ICACHE_INVALIDATE_WORKAROUND(scratch);		  \
	    cache ICACHE_ADDR_HIT_INVALIDATE, 0(addr)

#ifdef MT7510_DCACHE_TEST
#define CACHE_TEST_FAIL_GPIO		9
#define CACHE_TEST_PASS_GPIO		8
#define CACHE_TEST_DONE_GPIO		10

		la		t1, CR_ARB_BASE		//cache test decided by hwtrap		
		lw		t2, 0x8c(t1)
		nop
		
		srl		t2, t2, 22
		andi		t2, t2, 0x3
		beq		t2, 0, normal_init		
		nop

		/*Init GPIO Configuration*/
		/*GPIO 8,9,10*/
		li       a0, CACHE_TEST_FAIL_GPIO
		li	a1, 1
		jal     turnon_gpio
		nop
		
		li       a0, CACHE_TEST_PASS_GPIO
		li	a1, 1
		jal     turnon_gpio
		nop
		
		li       a0, CACHE_TEST_DONE_GPIO
		li	a1, 1
		jal     turnon_gpio
		nop

		/*Test start*/
		jal DCacheTag_test
		nop
		bnez		v0, ct_fail
		nop

		jal 	DCacheData_test
		nop
		bnez		v0, ct_fail
		nop

		/*Show Test Pass, Turn on GPIO 8*/

		li       a0, CACHE_TEST_PASS_GPIO
		li	a1, 0
		jal     turnon_gpio
		nop
		
		j ct_done
		nop

ct_fail:
		/*Show Test Fail, Turn on GPIO 9*/

		li       a0, CACHE_TEST_FAIL_GPIO
		li	a1, 0
		jal     turnon_gpio
		nop

ct_done:
		/*Show Test Done, Turn on GPIO 10*/
		
		li       a0, CACHE_TEST_DONE_GPIO
		li	a1, 0
		jal     turnon_gpio
		nop
		


normal_init:
#endif
#ifndef UNCACHE_MODE
		la		t1, 0x80000000
		la		t2, 0x80020000
1:
SET_MIPS3()
		cache   DCACHE_ADDR_HIT_WRITEBACK, 0(t1)
		sync
		cache 	ICACHE_ADDR_HIT_INVALIDATE, 0(t1)
SET_MIPS0()

		addiu 	t1, t1, 32
		bne		t2, t1, 1b
		nop
#endif
#endif

		DISPLAYLED(0x5e, 0x20000)

#ifndef TC3262
		li		t0, 0xf200ff15 			// Initialize the status register
		mtc0	t0, $12
		nop
		nop
#endif
#ifdef DEBUG
		li t7, 'f'
          	jal disp_character
          	nop

#endif
  	la	k0, 0x80000000
		jr	k0
		nop
error:
	/*  Error handling. Display error code (if device for this is available) and
	 *  enter an infinite loop (from init.h)
	 */
		b error
		nop

#ifdef TC3262

		.set noreorder

/************************************************************************
 *  sys_init_cpuclk
 ************************************************************************/
LEAF(sys_init_cpuclk)
#ifndef TC3262_FPGA
	    la		k0,	CR_ARB_BASE
		lw		k1, 0x64(k0)
		nop
		#ifndef MT75XX_REDUCE_SIZE
		srl		k1, k1, 16
		li		k0, 0
		beq   	k1, k0, tc3169_cpuclk
		nop
		li		k0, 1
		beq   	k1, k0, tc3182_cpuclk
		nop
		li		k0, 4
		beq   	k1, k0, rt63365_cpuclk
		nop
		#endif
		j		cpuclk_exit
		nop
#ifndef MT75XX_REDUCE_SIZE
tc3169_cpuclk:
		/* TC3262: Set CPU clock to 360Mhz */
	    la		k0,	CR_ARB_BASE
	    li		k1,	0x3b0000		
		nop
	    sw		k1,	0x58(k0)
		nop
		j		cpuclk_exit
		nop

tc3182_cpuclk:
		/* TC3182: */
	    la		v1,	CR_ARB_BASE

		/* set TC3182's PLL */
		li		t1, 0x95
		li		t2, 0x53				/* CPU=252Mhz */

		lw		t3, 0x8c(v1)
		nop
		srl		t4, t3, 8
		andi	t4, t4, 0x1
		beqz   	t4, tc3182_pll			/* check if TC3182LDV, set CPU clock to 252 */
		nop

		li		t2, 0x6e				/* CPU=333Mhz */
		lw		t3, 0x64(v1)
		nop
		andi	t3, t3, 0xf
		li		t4, 1
		beq		t4, t3, tc3182_pll 		/* check if TC3182 A3, set CPU clock to 450 */
		nop								/* else set CPU clock to 333 */

		li		t2, 0x95				/* CPU=450Mhz */
		b		tc3182_pll
		nop

		//li		t2, 0x43				/* CPU=204Mhz */
		//li		t2, 0x53				/* CPU=252Mhz */
		//li		t2, 0x63				/* CPU=300Mhz */
		//li		t2, 0x6e				/* CPU=333Mhz */
		//li		t2, 0x77				/* CPU=360Mhz */
		//li		t2, 0x7f				/* CPU=384Mhz */
		//li		t2, 0x85				/* CPU=402Mhz */
		//li		t2, 0x95				/* CPU=450Mhz */

tc3182_pll:	
		sll		a0, t1, 16
		ori		a0, 0x3 
	    sw		a0,	0x58(v1)
		nop

// wait 50 us
		li		t0,	5000
1:                              		/* wait 50 us */
		subu 	t0,	1
		bnez	t0,	1b
		nop

    	ble  	t1, t2, tc3182_pll2
    	nop
		addi	t1, t1, -3
		j		tc3182_pll
		nop

tc3182_pll2:	
    	beq  	t1, t2, cpuclk_exit
    	nop

		sll		a0, t2, 16
		ori		a0, 0x3 
	    sw		a0,	0x58(v1)
		nop

// wait 50 us
		li		t0,	5000
1:                              		/* wait 50 us */
		subu 	t0,	1
		bnez	t0,	1b
		nop

		j		cpuclk_exit
		nop


rt63365_cpuclk:
#if 1 //modify bulk output value
        la      k0, CR_ARB_BASE
		lw      k1, 0x90(k0)
		nop
		and    k1, k1, 0x83ffffff
		or     k1, k1, 0x48000000
		sw      k1, 0x90(k0)
		nop
#endif  
	    la		k0,	CR_ARB_BASE
		lw		t3, 0x8c(k0)
		nop
		srl		s2, t3, 24
		andi	s2, s2, 0x3				/* DRAM type */
		srl		s3, t3, 26
		andi	s3, s3, 0x1				/* Clock ratio */
		srl		s4, t3, 8
		andi	s4, s4, 0x3				/* Package selection */

		andi	t3, s2, 0x2				/* only SDR needs to lower/higher CPU clock */
		bnez   	t3, cpuclk_exit			
		nop

		andi	t0, s4, 0x2				/* check package is RT6855/RT63365 or RT6856/RT63368 */	
		bnez	t0, rt63368_pll
		nop

		bnez	s3, rt63365_ratio4_pll
		nop

#define DIVF			s5
#define DIVQ  			s6

rt63365_ratio3_pll:

		/* RT6855/RT63365 : 500Mhz to 420Mhz */

		/* DIVF from 99 downto 83 */
		/* DIVQ is 2 */
		li		DIVF, 99
		li		DIVQ, 2

rt63365_ratio3_pll_loop:
		lw		t0, 0x1d0(k0)
		nop
		li		t1, 0xff00f8ff
		and		t0, t0, t1
		sll		t1, DIVF, 16
		or		t0, t0, t1
		sll		t1, DIVQ, 8
		or		t0, t0, t1
		sw		t0, 0x1d0(k0)
		nop

// wait 50 us
		li		t0,	5000
1:                              		/* wait 50 us */
		subu 	t0,	1
		bnez	t0,	1b
		nop

		li		t0, 83
    	beq  	DIVF, t0, cpuclk_exit
    	nop
		addi	DIVF, -1
		j		rt63365_ratio3_pll_loop
		nop

rt63365_ratio4_pll:

		/* RT6855/RT63365 : 500Mhz to 560Mhz */

		/* DIVF from 99 downto 111 */
		/* DIVQ is 2 */
		li		DIVF, 99
		li		DIVQ, 2

rt63365_ratio4_pll_loop:
		lw		t0, 0x1d0(k0)
		nop
		li		t1, 0xff00f8ff
		and		t0, t0, t1
		sll		t1, DIVF, 16
		or		t0, t0, t1
		sll		t1, DIVQ, 8
		or		t0, t0, t1
		sw		t0, 0x1d0(k0)
		nop

// wait 50 us
		li		t0,	5000
1:                              		/* wait 50 us */
		subu 	t0,	1
		bnez	t0,	1b
		nop

		li		t0, 111
    	beq  	DIVF, t0, cpuclk_exit
    	nop
		addi	DIVF, 1
		j		rt63365_ratio4_pll_loop
		nop

rt63368_pll:
		/* RT6856/RT63368 : 665Mhz to 560Mhz */

		/* DIVF from 132 downto 119 */
		/* DIVQ is 1 */
		li		DIVF, 132
		li		DIVQ, 1

rt63368_pll_loop1:
		lw		t0, 0x1cc(k0)
		nop
		nop
		li		t1, 0xff00f8ff
		and		t0, t0, t1
		sll		t1, DIVF, 16
		or		t0, t0, t1
		sll		t1, DIVQ, 8
		or		t0, t0, t1
		sw		t0, 0x1cc(k0)
		nop

// wait 50 us
		li		t0,	5000
1:                              		/* wait 50 us */
		subu 	t0,	1
		bnez	t0,	1b
		nop

		li		t0, 119
    	beq  	DIVF, t0, rt63368_pll_loop1_exit
    	nop
		addi	DIVF, -1
		j		rt63368_pll_loop1
		nop

rt63368_pll_loop1_exit:

		/* DIVF from 237 downto 223 */
		/* DIVQ is 2 */
		li		DIVF, 237
		li		DIVQ, 2

rt63368_pll_loop2:
		lw		t0, 0x1cc(k0)
		nop
		nop
		li		t1, 0xff00f8ff
		and		t0, t0, t1
		sll		t1, DIVF, 16
		or		t0, t0, t1
		sll		t1, DIVQ, 8
		or		t0, t0, t1
		sw		t0, 0x1cc(k0)
		nop

// wait 50 us
		li		t0,	5000
1:                              		/* wait 50 us */
		subu 	t0,	1
		bnez	t0,	1b
		nop

		li		t0, 223
    	beq  	DIVF, t0, cpuclk_exit
    	nop
		addi	DIVF, -2
		j		rt63368_pll_loop2
		nop

#endif
#endif //MT75XX_REDUCE_SIZE
cpuclk_exit:

		jr		ra
		move	v0, zero
END(sys_init_cpuclk)

/*
 * Cache attribute values in the C field of EntryLo and the
 * K0 field of Config
 */
#define K_CacheAttrCWTnWA	0			/* Cacheable, write-thru, no write allocate */
#define K_CacheAttrCWTWA	1			/* Cacheable, write-thru, write allocate */
#define K_CacheAttrU		2			/* Uncached */
#define K_CacheAttrC		3			/* Cacheable */
#define K_CacheAttrCN		3			/* Cacheable, non-coherent */
#define K_CacheAttrCCE		4			/* Cacheable, coherent, exclusive */
#define K_CacheAttrCCS		5			/* Cacheable, coherent, shared */
#define K_CacheAttrCCU		6			/* Cacheable, coherent, update */
#define K_CacheAttrUA		7			/* Uncached accelerated */

#define S_ConfigMM              18     /* 24K specific, merging enable/disable */
#define M_ConfigMM              (0x1 << S_ConfigMM)

/*  Generic MIPS32/MIPS64 fields of CONFIG0 register (ie the ones not
 *  reserved for implementations)
 */
#define CONFIG0_MIPS32_64_MSK  0x8000ffff

/* MIPS 34K specifics */
#define STATUS_MIPS34K	    0
#define CONFIG0_MIPS34K  ((K_CacheAttrCN << S_ConfigK23) |\
			  (K_CacheAttrCN << S_ConfigKU)  |\
			  (M_ConfigMM))

/*  Generic MIPS32/MIPS64 fields of STATUS register (ie the ones not 
 *  reserved for implementations)
 */
#define STATUS_MIPS32_64_MSK   0xfffcffff

/*  Setup of STATUS register used for MIPS32/MIPS64 processors
 *  FR field only relevant for MIPS64 (Read only for MIPS32)
 */
#define STATUS_MIPS32_64   (M_StatusBEV | M_StatusFR)

#ifdef UNCACHE_MODE
#define CONFIG0_MIPS32_64    (K_CacheAttrU << S_ConfigK0)
#else
#define CONFIG0_MIPS32_64    (K_CacheAttrCN << S_ConfigK0)
//#define CONFIG0_MIPS32_64    (K_CacheAttrCWTnWA << S_ConfigK0)
#endif

/*
 *************************************************************************
 *                S O F T W A R E   G P R   I N D I C E S                *
 *************************************************************************
 *
 * These definitions provide the index (number) of the GPR, as opposed
 * to the assembler register name ($n).
 */

#define R_zero			 0
#define R_AT			 1
#define R_v0			 2
#define R_v1			 3
#define R_a0			 4
#define R_a1			 5
#define R_a2			 6
#define R_a3			 7
#define R_t0			 8
#define R_t1			 9
#define R_t2			10
#define R_t3			11
#define R_t4			12
#define R_t5			13
#define R_t6			14
#define R_t7			15
#define R_s0			16
#define R_s1			17
#define R_s2			18
#define R_s3			19
#define R_s4			20
#define R_s5			21
#define R_s6			22
#define R_s7			23
#define R_t8			24
#define R_t9			25
#define R_k0			26
#define R_k1			27
#define R_gp			28
#define R_sp			29
#define R_fp			30
#define R_s8			30
#define R_ra			31


#define KSEG0BASE		  0x80000000

/*  We use ssnop instead of nop operations in order to handle 
 *  superscalar CPUs.
 *  The "sll zero,zero,1" notation is compiler backwards compatible.
 */
#define SSNOP   sll zero,zero,1
#define EHB     sll zero,zero,3
#define NOPS	SSNOP; SSNOP; SSNOP; EHB

#define MFC0_SEL_OPCODE(dst, src, sel)\
	  	.##word (0x40000000 | ((dst)<<16) | ((src)<<11) | (sel))

#define MTC0_SEL_OPCODE(src, dst, sel)\
	  	.##word (0x40800000 | ((src)<<16) | ((dst)<<11) | (sel));\
		NOPS

/************************************************************************
 *  sys_init_processor
 ************************************************************************/
LEAF(sys_init_processor)
#if 0
		MFC0_SEL_OPCODE(R_t0, 16, 7)
		li  	t1, (1<<8)
		or		t0, t1
		MTC0_SEL_OPCODE(R_t0, 16, 7)
#endif
		/* Setup MIPS34K specifics (implementation dependent fields) */
		mfc0 	t0, C0_Config 
		li		t1, CONFIG0_MIPS32_64_MSK
		and		t0, t1
		li		t1, CONFIG0_MIPS34K
		or		t0, t1
		mtc0	t0, C0_Config 

		mfc0   	t0, C0_Status 
		li		t1, STATUS_MIPS32_64_MSK
		and		t0, t1
		li		t1, STATUS_MIPS34K
		or		t0, t1
		mtc0	t0, C0_Status 

		/* Setup generic MIPS32/MIPS64 fields of STATUS register */
		mfc0   	t0, C0_Status 
		li		t1, ~STATUS_MIPS32_64_MSK
		and		t0, t1
		li		t1, STATUS_MIPS32_64
		or		t0, t1
		mtc0	t0, C0_Status 

		/* Setup generic MIPS32 fields of CONFIG0 register */
		mfc0   	t0, C0_Config 
		li		t1, ~CONFIG0_MIPS32_64_MSK
		and		t0, t1
		li		t1, CONFIG0_MIPS32_64
		or		t0, t1
		mtc0	t0, C0_Config 

		jr		ra
		move	v0, zero
END(sys_init_processor)

/************************************************************************
 *  sys_init_cache
 ************************************************************************/
LEAF(sys_init_cache)

#define RA					t4
#define icache_size			t3
#define icache_linesize		t2
#define dcache_size			t1
#define dcache_linesize		t0

		move	RA, ra

		/* set icache, dcache size to 32KB only for FPGA board */
#ifdef TC3262_FPGA
		mfc0    s5, C0_Config 
		MFC0_SEL_OPCODE( R_s6, R_C0_Config1, R_C0_SelConfig1 )

		/* Enable write access to config1 */
		li		t0, 1<<19
		or		t0, s5, t0
		mtc0	t0, C0_Config 

		li  	s0, 2

		/* Set Icache settings to requested values */
		li		t0, ~(M_Config1IS | M_Config1DS)
		and		t0, s6, t0

		li		t1, S_Config1IS
		sllv	t1, s0, t1
		or		t0, t1

		/* Set Dcache settings to requested values */
		li		t1, S_Config1DS
		sllv	t1, s0, t1
		or		t0, t1

		/* Write CONFIG1 register */
		MTC0_SEL_OPCODE( R_t0, R_C0_Config1, R_C0_SelConfig1 )

		/* Disable write access to config1 */
		mtc0	s5, C0_Config 

		/* Empty pipeline */
		nop; nop; nop; nop; nop; nop
#endif

		/* L1 cache */
		bal		sys_determine_icache_linesize
		nop
		move	icache_linesize, v0

		bal		sys_determine_icache_lines
		nop
		multu	icache_linesize, v0
		mflo	icache_size

		bal		sys_determine_dcache_linesize
		nop
		move	dcache_linesize, v0

		bal		sys_determine_dcache_lines
		nop
		multu	dcache_linesize, v0
		mflo	dcache_size

		/* Initialise instruction cache */
		move	a0, icache_size
		move	a1, icache_linesize
		bal		sys_init_icache
		nop
	
		/* Initialise data cache */
		move	a0, dcache_size
		move	a1, dcache_linesize
		bal		sys_init_dcache
		nop

		/* Done */
		jr		RA
		move	v0, zero
END(sys_init_cache)


#define R_C0_DTagLo	      	28
#define R_C0_SelDTagLo	    2

#define R_C0_ITagLo			28
#define R_C0_SelITagLo		0

LEAF( sys_init_icache )
		/* 24K/24KE/34K : Clear ITagLo */
		MTC0_SEL_OPCODE( R_zero, R_C0_ITagLo, R_C0_SelITagLo )

		/* Calc an address that will correspond to the first cache line */
		li		a2, KSEG0BASE

		/* Calc an address that will correspond to the last cache line  */
		addu	a3, a2, a0
		subu    a3, a1

		/* Loop through all lines, invalidating each of them */
1:	
SET_MIPS3()
		cache	ICACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
SET_MIPS0()
		bne		a2, a3, 1b
		addu	a2, a1

		jr		ra
		nop
END(sys_init_icache )

LEAF(sys_init_dcache )
		/* 24K/24KE/34K : Clear DTagLo */
		MTC0_SEL_OPCODE( R_zero, R_C0_DTagLo, R_C0_SelDTagLo )

		/* Calc an address that will correspond to the first cache line */
		li		a2, KSEG0BASE
	
		/* Calc an address that will correspond to the last cache line  */
		addu	a3, a2, a0
		subu    a3, a1

		/* Loop through all lines, invalidating each of them */
1:	
SET_MIPS3()
		cache	DCACHE_INDEX_STORE_TAG, 0(a2)	/* clear tag */
SET_MIPS0()
		bne		a2, a3, 1b
		addu	a2, a1

		jr		ra
		nop
END(sys_init_dcache )

LEAF(sys_determine_icache_linesize)	

		/* Read CONFIG1 register, which holds implementation data */
		MFC0_SEL_OPCODE( R_t9, R_C0_Config1, R_C0_SelConfig1 )

#define config1	t9

		/* I-cache line size */
		li		t8, M_Config1IL
		and		t8, config1
		li		t7, S_Config1IL
		srl		t8, t7
		li		t7, 0x2
		sll		v0, t7, t8

		jr		ra
		nop
END(sys_determine_icache_linesize)	
	
LEAF(sys_determine_icache_lines)	

		/* Read CONFIG1 register, which holds implementation data */
		MFC0_SEL_OPCODE( R_t9, R_C0_Config1, R_C0_SelConfig1 )

#define config1	t9

		/* I-cache lines
		 * Calculated as associativity * sets per way
		 */
		li		t8, M_Config1IA
		and		t8, config1
		li		t7, S_Config1IA
		srl		t8, t7
		addiu	t8,1				/* t8 = associativity	*/

		li		t7, M_Config1IS
		and		t7, config1
		li		t9, S_Config1IS
		srl		t7, t9
		li		t9, 0x40
		sll		t7, t9, t7			/* t7 = sets per way	*/

		multu	t8, t7
		mflo    v0

		jr		ra
		nop
END(sys_determine_icache_lines)

LEAF(sys_determine_dcache_linesize)	

		/* Read CONFIG1 register, which holds implementation data */
		MFC0_SEL_OPCODE( R_t9, R_C0_Config1, R_C0_SelConfig1 )

#define config1	t9

		/* D-cache line size */
		li		t8, M_Config1DL
		and		t8, config1
		li		t7, S_Config1DL
		srl		t8, t7
		li		t7, 0x2
		sll		v0, t7, t8

		jr		ra
		nop
END(sys_determine_dcache_linesize)	

LEAF(sys_determine_dcache_lines)	
		/* Read CONFIG1 register, which holds implementation data */
		MFC0_SEL_OPCODE( R_t9, R_C0_Config1, R_C0_SelConfig1 )

#define config1	t9

		/* D-cache lines
		 * Calculated as associativity * sets per way
		 */
		li		t8, M_Config1DA
		and		t8, config1
		li		t7, S_Config1DA
		srl		t8, t7
		addiu	t8,1				/* t8 = associativity	*/

		li		t7, M_Config1DS
		and		t7, config1
		li		t9, S_Config1DS
		srl		t7, t9
		li		t9, 0x40
		sll		t7, t9, t7			/* t7 = sets per way	*/

		multu	t8, t7
		mflo    v0

		jr		ra
		nop
END(sys_determine_dcache_lines)

#ifndef MT75XX_REDUCE_SIZE
/************************************************************************
 *
 *                          sys_init_dmc
 *  Description :
 *  -------------
 *  Perform DMC initialization
 *
 *  Parameters :
 *  ------------
 *
 *  Return values :
 *  ---------------
 *  0 If OK, error code != 1 if error
 *
 ************************************************************************/
LEAF(sys_init_dmc)

	    la		k0,	CR_ARB_BASE
		lw		k1, 0x64(k0)
		nop
		srl		k1, k1, 16
		li		k0, 4					/* RT63365 */
		beq   	k1, k0, rt63365_pre_init_dmc
		nop
		j		pre_init_dmc_done
		nop

rt63365_pre_init_dmc:
	    la		v1,	CR_ARB_BASE
		lw		t3, 0x8c(v1)
		nop
		srl		s2, t3, 24
		andi	s2, s2, 0x3				/* DRAM type */
		li		t3, 3					/* check if DDR2 type */
		bne   	s2, t3, pre_init_dmc_done			
		nop

		/* set DDR2 pin re-shuffle enable */
		lw		t0, 0x4(v1)
		nop
		li		t1, (1<<23)
		or		t0, t0, t1
		sw		t0, 0x4(v1)
		nop
		j		pre_init_dmc_done
		nop

pre_init_dmc_done:

		/* de-assert DRAM controller reset */
	    la		v1,	CR_ARB_BASE
		li  	t0, 0x00000000      
		sw		t0, 0x40(v1)
		nop

	    la		k0,	CR_ARB_BASE
		lw		k1, 0x64(k0)
		nop
		srl		k1, k1, 16
		li		k0, 3					/* RT63165 */
		beq   	k1, k0, rt63165_dmc
		nop
		li		k0, 4					/* RT63365 */
		beq   	k1, k0, rt63365_dmc
		nop
		j		dmc_done
		nop

rt63165_dmc:
		lw		t3, 0x8c(v1)
		nop
		srl		s0, t3, 13
		andi	s0, s0, 0x7				/* DDR memory size */
		srl		s1, t3, 31				/* FPGA indication */
		srl		t3, t3, 25
		andi	t3, t3, 0x1
		bnez   	t3, ddr_init			
		nop

sdram_init:
		li		v1, CR_DMC_BASE		

		#ifdef SDRAM_16M
    	li    	t0,	0x80110096    		/* col 9 row 12 */
		#else
		#ifdef SDRAM_32M
    	li    	t0,	0x80120096    		/* col 9 row 13 */
		#else
    	li    	t0,	0x80010096    		/* col 8 row 12 */
		#endif
		#endif

		sw		t0, 0x4(v1)	
		nop

1:                              		
		lw		t0, 0x4(v1)	
		li		t1, (1<<30)
		and		t0,	t0, t1
		beqz	t0,	1b
		nop

		j		dmc_done
		nop
		
ddr_init:
		/* wait 200us for 50Mhz */ 
		li		t0,	5000
1:                              		
		subu	t0,	0x01
		bnez	t0,	1b
		nop

		li 		v1, CR_DMC_BASE

		lw 		t1, 0x44(v1)			
		li		t0, 0xffe0ffff
		and		t1, t1, t0

		li 		t0, (0xe<<16)			/* DRAM Size 256 x 16 */

dmc_ddr_size_8mb:
		li		t2, 1
		bne		s0, t2, dmc_ddr_size_16mb
		nop
		li 		t0, (0x6<<16)			/* DRAM Size 64 x 16 */
		b		dmc_ddr_size_done
		nop
		
dmc_ddr_size_16mb:
		li		t2, 2
		bne		s0, t2, dmc_ddr_size_64mb
		nop
		li 		t0, (0xa<<16)			/* DRAM Size 128 x 16 */
		b		dmc_ddr_size_done
		nop

dmc_ddr_size_64mb:
		li		t2, 4
		bne		s0, t2, dmc_ddr_size_128mb
		nop
		li 		t0, (0x12<<16)			/* DRAM Size 512 x 16 */
		b		dmc_ddr_size_done
		nop

dmc_ddr_size_128mb:
		li		t2, 5
		bne		s0, t2, dmc_ddr_size_256mb
		nop
		li 		t0, (0x16<<16)			/* DRAM Size 1024 x 16 */
		b		dmc_ddr_size_done
		nop

dmc_ddr_size_256mb:
		li		t2, 6
		bne		s0, t2, dmc_ddr_size_done
		nop
		li 		t0, (0x1a<<16)			/* DRAM Size 2048 x 16 */
		b		dmc_ddr_size_done
		nop

dmc_ddr_size_done:
		or 		t0, t0, t1
		sw 		t0, 0x44(v1)			/* Set DRAM size */
		nop

		/* Only for FPGA */
		beqz	s1,	dmc_done
		nop

		li		t1, 0x002a0400
		sw 		t1, 0x8(v1)				
		nop

		li		t1, 0x24984186
		sw 		t1, 0x40(v1)			/* Set DDR Refresh Interval to 0x186 */
		nop

		lw 		t1, 0x4c(v1)			
		ori		t1, 1
		sw 		t1, 0x4c(v1)			/* Set DLL disabled on FPGA */
		nop

		j		dmc_done
		nop

rt63365_dmc:
		lw		t3, 0x8c(v1)
		nop
		srl		s0, t3, 13
		andi	s0, s0, 0x7				/* DDR memory size */
		srl		s1, t3, 31				/* FPGA indication */
		srl		s2, t3, 24
		andi	s2, s2, 0x3				/* DRAM type */
		srl		s3, t3, 26
		andi	s3, s3, 0x1				/* Clock ratio */
		srl		s4, t3, 8
		andi	s4, s4, 0x3				/* Package selection */
		andi	t3, s2, 0x2
		bnez   	t3, rt63365_ddr_init			
		nop

rt63365_sdram_init:
		li		v1, CR_DMC_BASE		

		/* write SDRAM_CFG0 */
		la		t0, rt63365_sdram_cfg0			/* load config from cfg0 */
		lw		t0, 0(t0)
		nop
		sw		t0, 0x0(v1)	
		nop

		/* write SDRAM_CFG1 */
		la		t0, rt63365_140mhz_sdram_cfg1	/* load config from cfg1+4*(DRAM size) */
		sll		s0, s0, 2
		add 	t0, t0, s0
		lw		t0, 0(t0)
		nop
		sw		t0, 0x4(v1)	
		nop

		/* Only for FPGA */
		beqz	s1,	1f
		nop

		lw		t0, 0x4(v1)	
		li		t1, 0xffff0000
		and		t0, t0, t1
		ori		t0, 0xc3				/* set FPGA SDRAM refresh to 0xc3 */
		sw 		t0, 0x4(v1)				
		nop

1:                              		
		lw		t0, 0x4(v1)	
		li		t1, (1<<30)
		and		t0,	t0, t1
		beqz	t0,	1b
		nop

		j		dmc_done
		nop

rt63365_ddr_init:
		/* wait 200us for 50Mhz */ 
		li		t0,	5000
1:                              		
		subu	t0,	0x01
		bnez	t0,	1b
		nop

		li 		v1, CR_DMC_BASE

		/* wait until DDR_CFG1 bit21 becomes 1 */
1:
		lw 		t0, 0x44(v1)		
		nop
		li		t1, (1<<21)	
		and		t0, t0, t1
		beqz	t0, 1b
		nop

		/* DDR1 or DDR2 */
		andi	s2, s2, 0x1	
		beqz	s2,	ddr1_adjust_size
		nop

		/* DDR2 support 32/64/128/256MB */
		addiu	s0, -3
		j		ddr_adjust_size_done
		nop

ddr1_adjust_size:
		/* DDR1 support 8/16/32/64MB */
		addiu	s0, -1

ddr_adjust_size_done:

		/* Clock ratio: 233 (0), 175 (1), 166 (2), 125 (3) */
		andi	t0, s4, 0x2				
		bnez	t0, 1f
		nop
		addi	s3, 2
1:

		/* write DDR_CFG0 */
		la		t0, rt63365_233mhz_ddr1_cfg0	
		beqz	s2,	1f
		nop
		la		t0, rt63365_233mhz_ddr2_cfg0	
1:
		sll		t1, s3, 4
		add		t0, t0, t1
		sll		t1, s0, 2
		add		t0, t0, t1
		lw 		t0, 0x0(t0)			
		nop
		sw 		t0, 0x40(v1)			
		nop

		/* write DDR_CFG1 */
		la		t0, rt63365_233mhz_ddr1_cfg1	
		beqz	s2,	1f
		nop
		la		t0, rt63365_233mhz_ddr2_cfg1	
1:
		sll		t1, s3, 4
		add		t0, t0, t1
		sll		t1, s0, 2
		add		t0, t0, t1
		lw 		t0, 0x0(t0)			
		nop
		sw 		t0, 0x44(v1)			
		nop

		/* write DDR_CFG2 */
		la		t0, rt63365_233mhz_ddr1_cfg2	
		beqz	s2,	1f
		nop
		la		t0, rt63365_233mhz_ddr2_cfg2	
1:
		sll		t1, s3, 2
		add		t0, t0, t1
		lw 		t0, 0x0(t0)			
		nop
		sw 		t0, 0x48(v1)			
		nop

		/* write DDR_CFG3 */
		la		t0, rt63365_233mhz_ddr1_cfg3	
		beqz	s2,	1f
		nop
		la		t0, rt63365_233mhz_ddr2_cfg3	
1:
		sll		t1, s3, 2
		add		t0, t0, t1
		lw 		t0, 0x0(t0)			
		nop
		sw 		t0, 0x4c(v1)			
		nop

		/* write DDR_CFG4 */
		la		t0, rt63365_233mhz_ddr1_cfg4	
		beqz	s2,	1f
		nop
		la		t0, rt63365_233mhz_ddr2_cfg4	
1:
		sll		t1, s3, 2
		add		t0, t0, t1
		lw 		t0, 0x0(t0)			
		nop
		sw 		t0, 0x50(v1)			
		nop

#if 1
		beqz    s2, 1f
		/* Only run with DDR2*/
		/* DQS delay use DLL detected value then fixed the delay with a constant delay 8 */
		la		t0, CR_ARB_BASE + 0x18
		lw		t2, 0(t0)
		andi	t3,	t2, 0x1F
		srl		t2, t2, 5
		addiu	t6, zero, 5
		mul		t0, t2, t6	
		addu	t0, t0, t3
		subu	t0, t0, 8
		div		t0, t6
		mflo	t2	
		mfhi	t3
		nop
		nop
		/*Write delay to ddrcfg4 [22:14] and [13:5]*/
		sll		t2, t2, 5
		or		t2, t2, t3
		sll		t4, t2, 9
		or		t2, t2, t4
		sll		t2, t2, 5
		li		t3, ~(((0x1FF<<14)|0x1FF)<<5)
		and		t1, t1, t3
		or		t1, t1, t2
		la		t0, CR_DMC_BASE
		lw      t2, 0x50(t0)
		or 		t1, t1, t2
		sw		t1, 0x50(t0)
		nop
		/*Enable DQS delay*/
		la      t0, CR_DMC_BASE
		lw		t1, 0x4c(t0)
		li		t2, (1<<28)
		or		t1, t1, t2
		sw		t1, 0x4c(t0)
		nop

1:	
#endif

		/* Only for FPGA */
		beqz	s1,	dmc_done
		nop

		li		t1, 0x002a0400
		sw 		t1, 0x8(v1)				
		nop

		lw 		t1, 0x40(v1)			
		li		t2, 0xffffe000
		and		t1, t1, t2
		ori		t1, 0x186
		sw 		t1, 0x40(v1)			/* Set DDR Refresh Interval to 0x186 */
		nop

		lw 		t1, 0x4c(v1)			
		ori		t1, 1
		sw 		t1, 0x4c(v1)			/* Set DLL disabled on FPGA */
		nop
		j		dmc_done
		nop

dmc_done:
		jr		ra
		nop

rt63365_sdram_cfg0:
			/*      140Mhz,     125Mhz */
		.word	0x11825282, 0x11826282 
rt63365_140mhz_sdram_cfg1:
			/* 140Mhz */
			/*         2MB,        8MB,       16MB,       32MB */
		.word	0x8000088A, 0x8001088A, 0x8011088A, 0x80120444
rt63365_125mhz_sdram_cfg1:
			/* 125Mhz */
			/*         2MB,        8MB,       16MB,       32MB */
		.word	0x800007A0, 0x800107A0, 0x801107A0, 0x801203CF

rt63365_233mhz_ddr1_cfg0:
			/*         8MB,       16MB,       32MB,       64MB */
		.word	0x24A1CE3E, 0x35222E32, 0x25222719, 0x35222719
rt63365_175mhz_ddr1_cfg0:
			/*         8MB,       16MB,       32MB,       64MB */
		.word	0x23A1AAAF, 0x33A1AAAA, 0x2399A555, 0x2399A555
rt63365_166mhz_ddr1_cfg0:
			/*         8MB,       16MB,       32MB,       64MB */
		.word	0x23998A2D, 0x23998A28, 0x23998514, 0x23998514
rt63365_125mhz_ddr1_cfg0:
			/*         8MB,       16MB,       32MB,       64MB */
		.word	0x231927A2, 0x2319279E, 0x231923CF, 0x229123CF

rt63365_233mhz_ddr1_cfg1:
			/*         8MB,       16MB,       32MB,       64MB */
		.word	0x22262424, 0x202A2424, 0x202E2424, 0x30322424
rt63365_175mhz_ddr1_cfg1:
			/*         8MB,       16MB,       32MB,       64MB */
		.word	0x22262324, 0x202A2324, 0x202E2323, 0x30322323
rt63365_166mhz_ddr1_cfg1:
			/*         8MB,       16MB,       32MB,       64MB */
		.word	0x12262323, 0x202A2323, 0x202E2323, 0x30322323
rt63365_125mhz_ddr1_cfg1:
			/*         8MB,       16MB,       32MB,       64MB */
		.word	0x12262223, 0x202A2223, 0x202E2223, 0x30322222

rt63365_233mhz_ddr1_cfg2:
		.word	0x00000033
rt63365_175mhz_ddr1_cfg2:
		.word	0x00000033
rt63365_166mhz_ddr1_cfg2:
		.word	0x00000033
rt63365_125mhz_ddr1_cfg2:
		.word	0x00000033

rt63365_233mhz_ddr1_cfg3:
		.word	0x00000002
rt63365_175mhz_ddr1_cfg3:
		.word	0x00000002
rt63365_166mhz_ddr1_cfg3:
		.word	0x00000002
rt63365_125mhz_ddr1_cfg3:
		.word	0x00000002

rt63365_233mhz_ddr1_cfg4:
		.word	0x00000000
rt63365_175mhz_ddr1_cfg4:
		.word	0x00000000
rt63365_166mhz_ddr1_cfg4:
		.word	0x00000000
rt63365_125mhz_ddr1_cfg4:
		.word	0x00000000

rt63365_233mhz_ddr2_cfg0:
			/*        32MB,       64MB,      128MB,      256MB */
		.word	0x35A3271B, 0x35A3271B, 0x35A3C71B, 0x35A5C71B
rt63365_175mhz_ddr2_cfg0:
			/*        32MB,       64MB,      128MB,      256MB */
		.word	0x241A6555, 0x241A6555, 0x241AE555, 0x241C6555
rt63365_166mhz_ddr2_cfg0:
			/*        32MB,       64MB,      128MB,      256MB */
		.word	0x241A4513, 0x241A4513, 0x241AC513, 0x241C2513
rt63365_125mhz_ddr2_cfg0:
			/*        32MB,       64MB,      128MB,      256MB */
		.word	0x2311C3Cf, 0x2311C3Cf, 0x231203CF, 0x231323CF
                            
rt63365_233mhz_ddr2_cfg1:
			/*        32MB,       64MB,      128MB,      256MB */
		.word	0x222E2424, 0x22322424, 0x22362424, 0x223A2424
rt63365_175mhz_ddr2_cfg1:
			/*        32MB,       64MB,      128MB,      256MB */
		.word	0x222E2323, 0x22322323, 0x22362323, 0x223A2323
rt63365_166mhz_ddr2_cfg1:
			/*        32MB,       64MB,      128MB,      256MB */
		.word	0x222E2323, 0x22322323, 0x22362323, 0x223A2323
rt63365_125mhz_ddr2_cfg1:
			/*        32MB,       64MB,      128MB,      256MB */
		.word	0x112E2222, 0x11322222, 0x11362222, 0x113A2222

rt63365_233mhz_ddr2_cfg2:
		.word	0x40000843
rt63365_175mhz_ddr2_cfg2:
		.word	0x40000643
rt63365_166mhz_ddr2_cfg2:
		.word	0x40000643
rt63365_125mhz_ddr2_cfg2:
		.word	0x40000443

rt63365_233mhz_ddr2_cfg3:
		.word	0x00000402
rt63365_175mhz_ddr2_cfg3:
		.word	0x00000402
rt63365_166mhz_ddr2_cfg3:
		.word	0x00000402
rt63365_125mhz_ddr2_cfg3:
		.word	0x00000402

rt63365_233mhz_ddr2_cfg4:
		.word	0x0000000C
rt63365_175mhz_ddr2_cfg4:
		.word	0x00000009
rt63365_166mhz_ddr2_cfg4:
		.word	0x00000009
rt63365_125mhz_ddr2_cfg4:
		.word	0x00000007

END(sys_init_dmc)
#endif




/************************************************************************
 *
 *                          sys_init_mtk_dmc
 *  Description :
 *  -------------
 *  Perform MTK DMC initialization
 *
 *  Parameters :
 *  ------------
 *
 *  Return values :
 *  ---------------
 *  0 If OK, error code != 1 if error
  ************************************************************************/
#ifndef MT75XX_FPGA
#define DDR2	0
#define DDR3	1
#else
#define SDRAM	0
#define DDR3	1
#define DDR1	2
#define DDR2	3
#endif
#define DRAM_SIZE_2MB 0
#define DRAM_SIZE_8MB 1
#define DRAM_SIZE_16MB 2
#define DRAM_SIZE_32MB 3
#define DRAM_SIZE_64MB 4
#define DRAM_SIZE_128MB 5
#define DRAM_SIZE_256MB 6
#define DRAM_SIZE_512MB 7
#define XTAL_INPUT_FREQ_25MHZ	0
#define XTAL_INPUT_FREQ_20MHZ	1
#define XTAL_INPUT_FREQ_40MHZ	2
#define DRAMC_WAIT_CMD_RESPONSE_MAX_CNT 50000
#define REG_RW_DELAY	10 // delay for register read/write
#define CLK_CYCLE_NS	s7 // store the time per clock cycle in s7, unit: nano second
#define DLY_NS s6 // store the nano second to be delayed
#define DLY_RA	s5
#define XTAL_SRC_SEL	s4 // Xtal input frequency select

#define MEMPLL1_CONFIG_FOR_SSC

LEAF(sys_init_mtk_dmc)
		move DLY_RA, ra

MTK_DMC_INIT_START:
		// judge the platform, DRAM type & size
		la		k0, CR_ARB_BASE
		lw		t0, 0x8c(k0)
		nop
		srl		s0, t0, 31 // FPGA indication

		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		//ASIC
		srl	s1, t0, 18
		andi	s1, s1, 0x1	// DRAM type
		j 88f
		nop	
1:  //FPGA
		srl		s1, t0, 24
		andi	s1, s1, 0x3	// DRAM type
88:
		srl		s2, t0, 13
		andi	s2, s2, 0x7	// DRAM size
		
		srl		XTAL_SRC_SEL, t0, 22
		andi	XTAL_SRC_SEL, XTAL_SRC_SEL, 0x3	// Xtal Freq.

		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		CLK_CYCLE_NS, 1 // store the time per clock cycle in s7, unit: nano second, for ASIC 750MHz clock
		j 88f
		nop	
1:
		li		CLK_CYCLE_NS, 16 // store the number of clock cycle for one nano second in s7, FPGA
88:

		/* de-assert DRAM controller reset */
	  la		k0,	CR_ARB_BASE
		li  	t0, 0x00000000      
		sw		t0, 0x40(k0)
		nop
		
		la		DLY_NS,	200000  // wait 200us
		bal		dly_ns_mt75xx
		nop
		
		la		k0, CR_DMC_BASE // k0 stores DRAMC base address

		// FPGA platform
		bnez	s0, PLL_CLK_CFG_DONE // FPGA doesn't need to config PLL & clock source setting
		nop
			
		/* *** PLL & clock source setting *** */
		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		li		t0, 0xc2031257 // set FREQDIV2, WTLAT, DATLAT, AC timing, ODT/OCD control, DDR2EN for DDR2 //CML_20130307, for support list
		sw		t0, 0x7c(k0)
		nop
		
		j 99f
		nop
3:
		// DDR3
		li		t0, 0xa18711dd // set FREQDIV2, WTLAT, DATLAT, AC timing, ODT/OCD control for DDR3-800
		sw		t0, 0x7c(k0)
		nop
99:

		#ifdef MEMPLL1_CONFIG_FOR_SSC
		lw		t0, 0x60c(k0)
		li		t1, 0x00000001
		or		t0,	t0, t1
		sw		t0, 0x60c(k0)
		
		lw		t0, 0x600(k0)
		li		t1, 0xfffffffc
		and		t0,	t0, t1
		sw		t0, 0x600(k0)

		li		t0, 0x1e000000
		sw		t0, 0x608(k0)
		nop
		
		lw		t0, 0x60c(k0)
		li		t1, 0xffffefff
		and		t0,	t0, t1
		sw		t0, 0x60c(k0)
		
		lw		t0, 0x60c(k0)
		li		t1, 0x00001000
		or		t0,	t0, t1
		sw		t0, 0x60c(k0)

		lw		t0, 0x60c(k0)
		li		t1, 0xffffffef
		and		t0,	t0, t1
		sw		t0, 0x60c(k0)
		
		lw		t0, 0x600(k0)
		li		t1, 0xfffffff3
		and		t0,	t0, t1
		sw		t0, 0x600(k0)

		lw		t0, 0x600(k0)
		li		t1, 0x08000000
		or		t0,	t0, t1
		sw		t0, 0x600(k0)

		lw		t0, 0x61c(k0)
		li		t1, 0xffffffe0
		and		t0,	t0, t1
		li		t1, 0x0000000f
		or		t0, t0, t1
		sw		t0, 0x61c(k0)

		lw		t0, 0x618(k0)
		li		t1, 0x3fffffff
		and		t0,	t0, t1
		sw		t0, 0x618(k0)

		lw		t0, 0x604(k0)
		li		t1, 0xfffffff1
		and		t0,	t0, t1
		sw		t0, 0x604(k0)

		lw		t0, 0x604(k0)
		li		t1, 0xfffffffe
		and		t0,	t0, t1
		li		t1, 0x00000001
		or		t0, t0, t1
		sw		t0, 0x604(k0)

		lw		t0, 0x60c(k0)
		li		t1, 0xff7fffff
		and		t0,	t0, t1
		li		t1, 0x00800000
		or		t0, t0, t1
		sw		t0, 0x60c(k0)

		lw		t0, 0x610(k0)
		li		t1, 0xffff0000
		and		t0,	t0, t1
		li		t1, 0x000000fa
		or		t0, t0, t1
		sw		t0, 0x610(k0)

		lw		t0, 0x614(k0)
		li		t1, 0xfffffff0
		and		t0,	t0, t1
		sw		t0, 0x614(k0)

		lw		t0, 0x610(k0)
		li		t1, 0x000fffff
		and		t0,	t0, t1
		//li		t1, 0x13a00000
		li		t1, 0x4e800000		//YMC_20131223
		or		t0, t0, t1
		sw		t0, 0x610(k0)

		lw		t0, 0x614(k0)
		li		t1, 0xff0000ff
		and		t0,	t0, t1
		//li		t1, 0x00013a00  //YMC_20131219
		li		t1, 0x0004e800
		or		t0, t0, t1
		sw		t0, 0x614(k0)
		#endif //end of MEMPLL1_CONFIG_FOR_SSC

		// judge Xtal input frequence
		li		t0, XTAL_INPUT_FREQ_25MHZ
		beq		XTAL_SRC_SEL, t0, 25f	// Xtal input frequency 25 MHz
		nop
		
		// Xtal input frequency other than 25 MHz
		li		t0, 0x00000003 // set to 1-PLL sync mode, enable PLL2CLK_EN
		sw		t0, 0x640(k0)
		nop

		#ifdef MEMPLL1_CONFIG_FOR_SSC
		li		t0, 0x00000003 // set to DIV2_SEL change to 0
		#else
		li		t0, 0x00000002 // set to DIV2_SEL change to 0
		#endif //end of MEMPLL1_CONFIG_FOR_SSC
		sw		t0, 0x604(k0)
		nop
		
		j 333f
		nop
25:
		// Xtal input frequency 25 MHz
		li		t0, 0x00000023 // set to 1-PLL sync mode, enable PLL2CLK_EN
		sw		t0, 0x640(k0)
		nop

		#ifdef MEMPLL1_CONFIG_FOR_SSC
		li		t0, 0x00000001 // set to DIV2_SEL change to 0
		#else
		li		t0, 0x00000000 // set to DIV2_SEL change to 0
		#endif //end of MEMPLL1_CONFIG_FOR_SSC
		sw		t0, 0x604(k0)
		nop
333:
		
		#ifdef MEMPLL1_CONFIG_FOR_SSC
		li		t0, 0x1a003c00 // set RG_MEMPLL_BIAS_EN
		sw		t0, 0x600(k0)
		nop

		la		DLY_NS,	2000  // wait 2us
		bal		dly_ns_mt75xx
		nop

		li		t0, 0x3a003c00 // set RG_MEMPLL_BIAS_LPF_EN
		sw		t0, 0x600(k0)
		nop

		la		DLY_NS,	1000000  // wait 1ms
		bal		dly_ns_mt75xx
		nop

		li		t0, 0x3a213c10 // set RG_MEMPLL_EN
		sw		t0, 0x600(k0)
		nop

		#else
		li		t0, 0x12003c00 // set RG_MEMPLL_BIAS_EN
		sw		t0, 0x600(k0)
		nop
		
		la		DLY_NS,	2000  // wait 2us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x32003c00 // set RG_MEMPLL_BIAS_LPF_EN
		sw		t0, 0x600(k0)
		nop

		la		DLY_NS,	1000000  // wait 1ms
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x32213c10 // set RG_MEMPLL_EN
		sw		t0, 0x600(k0)
		nop
		#endif //end of MEMPLL1_CONFIG_FOR_SSC
		
		la		DLY_NS,	20000  // wait 20us
		bal		dly_ns_mt75xx
		nop

		li		t0, 0x0000002f // set RG_MEMPLL_DIV_EN
		sw		t0, 0x61c(k0)
		nop
		
		la		DLY_NS,	1000  // wait 1us
		bal		dly_ns_mt75xx
		nop
	
		// judge Xtal input frequence
		li		t0, XTAL_INPUT_FREQ_25MHZ
		beq		XTAL_SRC_SEL, t0, 25f	// Xtal input frequency 25 MHz
		nop
		
		// Xtal input frequency other than 25 MHz
		// DDR-800
		li		t0, 0x02211400 // set RG_MEMPLL2_FBKDIV
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x02211400 // set RG_MEMPLL3_FBKDIV
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x02211400 // set RG_MEMPLL4_FBKDIV
		sw		t0, 0x644(k0)
		nop
		
		li		t0, 0x00020000 // set RG_MEMPLL2_M4PDIV
		sw		t0, 0x624(k0)
		nop
		li		t0, 0x02211410 // set RG_MEMPLL2_EN
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL3_M4PDIV
		sw		t0, 0x630(k0)
		nop
		li		t0, 0x02211410 // set RG_MEMPLL3_EN
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL4_M4PDIV
		sw		t0, 0x648(k0)
		nop
		li		t0, 0x02211410 // set RG_MEMPLL4_EN
		sw		t0, 0x644(k0)
		nop
		
		la		DLY_NS,	20000  // wait 20us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x00000013 // enable ALLCLK_EN
		sw		t0, 0x640(k0)
		nop
		
		j 333f
		nop
25:
		// Xtal input frequency 25 MHz
	#ifdef TCSUPPORT_DMT_CO
		// DDR2-400
		li		t0, 0x02210400 // set RG_MEMPLL2_FBKDIV
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x02210400 // set RG_MEMPLL3_FBKDIV
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x02210400 // set RG_MEMPLL4_FBKDIV
		sw		t0, 0x644(k0)
		nop
		
		li		t0, 0x00020000 // set RG_MEMPLL2_M4PDIV
		sw		t0, 0x624(k0)
		nop
		li		t0, 0x02210410 // set RG_MEMPLL2_EN
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL3_M4PDIV
		sw		t0, 0x630(k0)
		nop
		li		t0, 0x02210410 // set RG_MEMPLL3_EN
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL4_M4PDIV
		sw		t0, 0x648(k0)
		nop
		li		t0, 0x02210410 // set RG_MEMPLL4_EN
		sw		t0, 0x644(k0)
		nop

	#else
		// DDR-800
		li		t0, 0x02210800 // set RG_MEMPLL2_FBKDIV
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x02210800 // set RG_MEMPLL3_FBKDIV
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x02210800 // set RG_MEMPLL4_FBKDIV
		sw		t0, 0x644(k0)
		nop
		
		li		t0, 0x00020000 // set RG_MEMPLL2_M4PDIV
		sw		t0, 0x624(k0)
		nop
		li		t0, 0x02210810 // set RG_MEMPLL2_EN
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL3_M4PDIV
		sw		t0, 0x630(k0)
		nop
		li		t0, 0x02210810 // set RG_MEMPLL3_EN
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL4_M4PDIV
		sw		t0, 0x648(k0)
		nop
		li		t0, 0x02210810 // set RG_MEMPLL4_EN
		sw		t0, 0x644(k0)
		nop
	#endif

		la		DLY_NS,	20000  // wait 20us
		bal		dly_ns_mt75xx
		nop
		
333:
	
		li		t0, 0x00000033 // enable PLL2CLK_EN
		sw		t0, 0x640(k0)
		nop

PLL_CLK_CFG_DONE:

		DLY_CLK_CYCLE(REG_RW_DELAY) // wait 10 bus clock

		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x0000d10d // set test agent 2 parameter
		sw		t0, 0x48(k0)
		nop	

		li		t0, 0x40100900 // set pinmux for DDR2
		sw		t0, 0xd8(k0)
		nop
		j 88f
		nop	
1:
		li		t0, 0xc0500900 // set pinmux[31:30] - 0x3 for DDR2 FPGA
		sw		t0, 0xd8(k0)
		nop
88:
	
		li		t0, 0x00000001 // reserved for DDR2
		sw		t0, 0xe4(k0)
		nop
	
		li		t0, 0x00000001 // set FIFO length
		sw		t0, 0x8c(k0)
		nop

		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x00000000 // reserved
		j 88f
		nop	
1:
		li		t0, 0x80000000 // FPGA DQS single-end output
88:
		sw		t0, 0x90(k0)
		nop

		li		t0, 0x80000000 // set DQS gating window fine-tuning for DDR2
		sw		t0, 0x94(k0)
		nop
	
		li		t0, 0x83080080 // set DQS gating window coarse-tuning for DDR2
		sw		t0, 0xdc(k0)
		nop

		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x1a080080 // set DQS gating window coarse-tuning for DDR2
		j 88f
		nop	
1:
		li		t0, 0x10008008 // FPGA no DQSN, set DQS gating window coarse-tuning for DDR2 //CML_20130104, for DDR2 performance
88:
		sw		t0, 0xe0(k0)
		nop
	
		j			99f
		nop
3:
		// DDR3
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
          li		t0, 0x1e00d10d // set test agent 2 parameter //CML_20130307, for support list
		sw		t0, 0x48(k0)
		nop	
		
		li		t0, 0x00100900 // set pinmux for DDR3
		sw		t0, 0xd8(k0)
		nop
		j 88f
		nop	
1:
		li		t0, 0xc0100900 // set pinmux for DDR3 FPGA
		sw		t0, 0xd8(k0)
		nop
88:

		la		DLY_NS,	200000  // wait 200us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x000000a3 // set DDR3EN, BC4 for DDR3
		sw		t0, 0xe4(k0)
		nop
		
		la		DLY_NS,	500000  // wait 500us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x00000001 // set FIFO length
		sw		t0, 0x8c(k0)
		nop

		li		t0, 0x00000000 // reserved
		sw		t0, 0x90(k0)
		nop
		
		li		t0, 0x00000000 // set DQS gating window fine-tuning for DDR3
		sw		t0, 0x94(k0)
		nop
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x83080080 // set DQS gating window coarse-tuning for DDR3
		sw		t0, 0xdc(k0)
		nop
		
		li		t0, 0x12080080 // set DQS gating window coarse-tuning for DDR3
		sw		t0, 0xe0(k0)
		nop
		
		j 88f
		nop	
1:
		li		t0, 0x83002002 // set DQS gating window coarse-tuning
		sw		t0, 0xdc(k0)
		nop
		
		li		t0, 0x11002002 // set DQS gating window coarse-tuning for DDR3
		sw		t0, 0xe0(k0)
		nop
		
88:

99:
		li		t0, 0x00000000 // reserved
		sw		t0, 0xf0(k0)
		nop
		
		// judge DRAM type & size to decide bank number
		li		t0, DDR3 //0x1
		beq		s1, t0, 8f	// DDR3 type, all DDR3 is 8 bank
		nop
		li		t0, DDR2 //0x3
		bne		s1, t0, 4f	// not DDR2 & DDR3 type, set as 4 bank
		nop
		li		t0, DRAM_SIZE_128MB //0x5
		bltu	s2, t0, 4f	// DDR2 type, size < 128 MB, 4 bank; else 8 bank
		nop
8:
		li		t0, 0x01000000 // 8-bank
		j			77f
		nop
4:
		li		t0, 0x00000000 // 4-bank
77:
		sw		t0, 0xf4(k0)
		nop
			
		li		t0, 0x00000080 // set MAXPENDCNT
		sw		t0, 0x168(k0)
		nop
		li		t0, 0x30000000 // enable DRAM clock
		sw		t0, 0x130(k0)
		nop
		
		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x40300900 // set DRAMEN for DDR2
		j 88f
		nop	
1:
		li		t0, 0xc0700900 // set DRAMEN for DDR2 FPGA
88:
		sw		t0, 0xd8(k0)
		nop
		
		DLY_CLK_CYCLE(REG_RW_DELAY)
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop

		li		t0, 0xf0040562 // set CMDHLD, 16Bit DQ, MATYPE[9:8], TRRD[7:6] for DDR2 //CML_20130307, for support list
		j 88f
		nop	
1:
		li		t0, 0xf00485a2 // set CMDHLD, 16Bit DQ, MATYPE[9:8], TRRD[7:6]  for DDR2 FPGA
88:
		
		// judge DRAM type & size to decide column address bit number
		li		t1, 0xfffffcff
		and		t0,	t0, t1 // clear column address width
		
		li		t1, DDR3
		beq		s1, t1, 10f	//	DDR3 type, all DDR3 column address width is 10 bit
		nop
		li		t1, DDR2
		bne		s1, t1, 9f	//	not DDR2 & DDR3 type, set column address width as 9 bit
		nop
		li		t1, DRAM_SIZE_64MB
		bltu	s2, t1, 9f	// DDR2 type, size < 64 MB, set column address width as 9 bit; else 10 bit
		nop
10:
		ori		t0, 0x00000200 // 10-bit
		j			66f
		nop
9:
		ori		t0, 0x00000100 // 9-bit
66:
		sw		t0, 0x4(k0)
		nop

		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x80000011 // set to new DQS gating, change to CL4 for DDR2
		sw		t0, 0x124(k0)
		nop
		
		li		t0, 0x0000c8b8 // enable DQS gating window auto calibration //CML_20130509, disable H/W gating window calibration
		sw		t0, 0x1c0(k0)
		nop
		
		li		t0, 0xc2031257 // set FREQDIV2, WTLAT, DATLAT, AC timing, ODT/OCD control, DDR2EN, change to CL4 for DDR2 //CML_20130307, for support list
		sw		t0, 0x7c(k0)
		nop
		
		li		t0, 0xf1200f01 // set DLLFRZ
		sw		t0, 0x28(k0)
		nop
		li		t0, 0x84000000 // set ADRDEC, WATRG, FASTOE, remove pipe line for DDR2
		sw		t0, 0x1e0(k0)
		nop
		
		j 88f
		nop	
1:
		li		t0, 0x80000033 // FPGA no DQSN //CML_20130104, for DDR2 performance
		sw		t0, 0x124(k0)
		nop
		
		li		t0, 0x9103123f //CML_20130104, for DDR2 performance
		sw		t0, 0x7c(k0)
		nop
		
		li		t0, 0xf1000301 // set DLLFRZ for DDR2 FPGA //CML_20130104, for DDR2 performance
		sw		t0, 0x28(k0)
		nop
		li		t0, 0x80000000 // set ADRDEC, WATRG, FASTOE for DDR2 FPGA
		sw		t0, 0x1e0(k0)
		nop
88:
		li		t0, 0x00000000 // reserved
		sw		t0, 0x158(k0)
		nop
		
		li		t0, 0x00111190 // reserved, rank mode // CML_20130104, for DDR2 performance
		sw		t0, 0x110(k0)
		nop
		
		DLY_CLK_CYCLE(5) //CML_20130104, for DDR2 performance
		
		j			99f
		nop
3:
		// DDR3
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x00300900 // set DRAMEN for DDR3
		j 88f
		nop	
1:
		li		t0, 0xc0300900 // set DRAMEN for DDR3 FPGA
88:
		sw		t0, 0xd8(k0)
		nop
		
		DLY_CLK_CYCLE(REG_RW_DELAY)
	
		// judge DRAM type & size to decide column address bit number
		li		t0, 0xf0740662 // enable CKEON for DDR3-800
		li		t1, 0xfffffcff
		and		t0,	t0, t1 // clear column address width
		
		li		t1, DDR3
		beq		s1, t1, 10f	//	DDR3 type, all DDR3 column address width is 10 bit
		nop
		li		t1, DDR2
		bne		s1, t1, 9f	//	not DDR2 & DDR3 type, set column address width as 9 bit
		nop
		li		t1, DRAM_SIZE_64MB
		bltu	s2, t1, 9f	// DDR2 type, size < 64 MB, set column address width as 9 bit; else 10 bit
		nop
10:
		ori		t0, 0x00000200 // 10-bit
		j			66f
		nop
9:
		ori		t0, 0x00000100 // 9-bit
66:
		sw		t0, 0x4(k0)
		nop

		li		t0, 0x80000011 // set to new DQS gating for DDR3
		sw		t0, 0x124(k0)
		nop

		li		t0, 0x0000c8b8 // enable DQS gating window auto calibration //CML_20130509, disable H/W gating window calibration
		sw		t0, 0x1c0(k0)
		nop

		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0xa18711d5 // set FREQDIV2, WTLAT, DATLAT, AC timing, ODT/OCD control, disable ODT before DRAM initial for DDR3-800
		sw		t0, 0x7c(k0)
		nop
		
		li		t0, 0xf1200f01 // set DLLFRZ for DDR3
		sw		t0, 0x28(k0)
		nop

		li		t0, 0x8c000000 // set ADRDEC, WATRG, FASTOE for DDR3 // enable FASTOE for CWL < 6
		sw		t0, 0x1e0(k0)
		nop

		j 88f
		nop	
1:
		li		t0, 0x918e32cd // set FREQDIV2, WTLAT, DATLAT, AC timing, ODT/OCD control for DDR3 FPGA
		sw		t0, 0x7c(k0)
		nop
		li		t0, 0xf1000301 // set DLLFRZ for DDR3
		sw		t0, 0x28(k0)
		nop
		li		t0, 0x88000000 // set ADRDEC, WATRG, FASTOE for DDR3 FPGA
		sw		t0, 0x1e0(k0)
		nop
88:

		li		t0, 0x00000000 // reserved
		sw		t0, 0x158(k0)
		nop
		
		li		t0, 0x00111190
		sw		t0, 0x110(k0)
		nop
99:		
		
		/* *** DRAM Initial Sequence *** */
		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0xf07402e2 // enable CKEON
		j 88f
		nop
1:
		li		t0, 0xf00405a2 // disable CKEON, turn off refresh when initial, test CMD to nop for DDR2 FPGA //CML_20130104, for DDR2 performance
88:
		j 99f
		nop
3:
		// DDR3
		li		t0, 0xf0740662 // enable CKEON for DDR3-800
99:
		// judge DRAM type & size to decide column address bit number
		li		t1, 0xfffffcff
		and		t0,	t0, t1 // clear column address width
		
		li		t1, DDR3
		beq		s1, t1, 10f	//	DDR3 type, all DDR3 column address width is 10 bit
		nop
		li		t1, DDR2
		bne		s1, t1, 9f	//	not DDR2 & DDR3 type, set column address width as 9 bit
		nop
		li		t1,	DRAM_SIZE_64MB
		bltu	s2, t1, 9f	// DDR2 type, size < 64 MB, set column address width as 9 bit; else 10 bit
		nop
10:
		ori		t0, 0x00000200 // 10-bit
		j			66f
		nop
9:
		ori		t0, 0x00000100 // 9-bit
66:
		sw		t0, 0x4(k0)
		nop
		
		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		li		t0, 0x00000007 // enable CKEFIXON for DDR2
		sw		t0, 0xe4(k0)
		nop
		
		la		DLY_NS,	400  // wait 400ns
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x00000004 // issue "Precharge All" for DDR2
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x4 // wait for PREA command response, bit[2]
		beqz	t0, 888b
		nop
		
		DLY_CLK_CYCLE(4) // tRP (7nCK by JEDEC spec, clock DRAMC:DRAM=1:2) //CML_20130207
				
		li		t0, 0x00000000
		sw		t0, 0x1e4(k0)
		nop
		
		li		t0, 0x00004000 // set MR2 for DDR2
		sw		t0, 0x88(k0)
		nop
		
		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop
		
		DLY_CLK_CYCLE(1) // tMRD (2nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		j			99f
		nop
3:
		// DDR3
		li		t0, 0x000000a7 // enable CKEFIXON for DDR3
		sw		t0, 0xe4(k0)
		nop		
		
		la		DLY_NS,	310  // wait 310 ns
		bal		dly_ns_mt75xx
		nop
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop

		li		t0, 0x00004200 // set MR2, RTT=ZQ/4, CWL=5 for DDR3-800
		j 88f
		nop
1:
		li		t0, 0x00004000 // set MR2, RTT=ZQ/4, CWL=6 for DDR3
88:
		sw		t0, 0x88(k0)
		nop
		
		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop
		
		DLY_CLK_CYCLE(2) // tMRD (4nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
99:		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		li		t0, 0x00006000 // set MR3
		sw		t0, 0x88(k0)
		nop
		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop

		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop

		DLY_CLK_CYCLE(1) // tMRD (2nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x00002040 // set MR1 for DDR2
		j 88f
		nop	
1:
		li		t0, 0x00002441 // FPGA disable #DQS & DLL, set MR1 for DDR2
88:
		sw		t0, 0x88(k0)
		nop

		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
				
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop

		DLY_CLK_CYCLE(1) // tMRD (2nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		li		t0, 0x00000b63 // set MR0, BL8, CL=4, DLL reset for DDR2 //0305 DR
		sw		t0, 0x88(k0)
		nop
		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
				
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop

		DLY_CLK_CYCLE(1) // tMRD (2nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop

		li		t0, 0x00000004 // issue "Precharge All" for DDR2
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x4 // wait for PREA command response, bit[2]
		beqz	t0, 888b
		nop

		DLY_CLK_CYCLE(4) // tRP (7nCK by JEDEC spec, clock DRAMC:DRAM=1:2) //CML_20130207

		li		t0, 0x00000000 //
		sw		t0, 0x1e4(k0)
		nop
		
		li		t0, 0x00000008 // issue "Auto Refresh" for DDR2
		sw		t0, 0x1e4(k0)
		nop

		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x8 // wait for AREF command response, bit[3]
		beqz	t0, 888b
		nop
		
		la		DLY_NS,	328  // wait 328ns
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x00000000 //
		sw		t0, 0x1e4(k0)
		nop

		li		t0, 0x00000008 // issue "Auto Refresh" for DDR2
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x8 // wait for AREF command response, bit[3]
		beqz	t0, 888b
		nop

		la		DLY_NS,	328  // wait 328ns
		bal		dly_ns_mt75xx
		nop
				
		li		t0, 0x00000000 //
		sw		t0, 0x1e4(k0)
		nop
		
		li		t0, 0x00000a63 // set MR0, DLL not reset for DDR2 // 0305 DR
		sw		t0, 0x88(k0)
		nop
		
		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop
		
		DLY_CLK_CYCLE(1) // tMRD (2nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x000023c0 // set MR1, enter OCD calibration for DDR2
		j 88f
		nop	
1:
		li		t0, 0x000027c1 // FPGA disable #DQS & DLL, set MR1, enter OCD calibration for DDR2
88:
		sw		t0, 0x88(k0)
		nop

		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop

		DLY_CLK_CYCLE(1) // tMRD (2nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x00002040 // set MR1, exit OCD calibration for DDR2
		j 88f
		nop	
1:
		li		t0, 0x00002441 // FPGA disable #DQS & DLL, set MR1, exit OCD calibration for DDR2
88:
		sw		t0, 0x88(k0)
		nop

		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop

		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop
		
		DLY_CLK_CYCLE(1) // tMRD (2nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0xc203123f // enable WODTEN, change to CL4 for DDR2 //CML_20130307, for support list //CML_20130801
		sw		t0, 0x7c(k0)
		nop
		li		t0, 0x00002205 // CKEFIXON for DDR2 // change RTT=120 //CML_20130422
		sw		t0, 0xe4(k0)
		nop

		j 88f
		nop	
1:
		li		t0, 0x9103122f //CML_20130104, for DDR2 performance
		sw		t0, 0x7c(k0)
		nop
		li		t0, 0x00000707 // disable CKEFIXON for DDR2 //CML_20130104, for DDR2 performance
		sw		t0, 0xe4(k0)
		nop
88:
		j			99f
		nop
3:
		// DDR3
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop

		DLY_CLK_CYCLE(2) // tMRD (4nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x00002004 // set MR1, enable DLL, RTT = RZQ/4 for DDR3
		j 88f
		nop	
1:
		li		t0, 0x00002001 // FPGA disable DLL, set MR1 for DDR3
88:
		sw		t0, 0x88(k0)
		nop

		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop
		
		DLY_CLK_CYCLE(2) // tMRD (4nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x00001531 // set MR0, BC4 on the fly, CL=7, DLL reset, WR=8 , PPD fast exit for DDR3
		j 88f
		nop	
1:
		li		t0, 0x00000911 // set MR0, BC4 on the fly, CL=8, DLL reset, WR=8 for DDR3
88:
		sw		t0, 0x88(k0)
		nop
		
		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop

		DLY_CLK_CYCLE(6) // tMRD (12nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		li		t0, 0x00000400 // set ZQCL for DDR3
		sw		t0, 0x88(k0)
		nop
		li		t0, 0x00000010 // issue ZQCL for DDR3
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x10 // wait for ZQC command response, bit[4]
		beqz	t0, 888b
		nop
		
		DLY_CLK_CYCLE(256) // tZQinit (512nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x00000000 // clear ZQCL
		sw		t0, 0x1e4(k0)
		nop
		li		t0, 0x00001100 // ??
		sw		t0, 0x1e4(k0)
		nop
		DLY_CLK_CYCLE(2) // tMRD (4nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		li		t0, 0x000022a7 
		sw		t0, 0xe4(k0)
		nop
	
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x8c000000 // enable R_DMWDATREG0 & R_DMFASTOE(WLAT0=0) for DDR3 // enable FASTOE for CWL < 6
		j 88f
		nop	
1:
		li		t0, 0x88000000 // enable R_DMWDATREG0 & R_DMFASTOE(WLAT0=0) for DDR3 FPGA
88:
		sw		t0, 0x1e0(k0)
		nop
		
99:

		li		t0, 0x0000ffff // set all DRAM addresses to 1
		sw		t0, 0x88(k0)
		nop
		
		li		t0, 0x00000020 // issue NOP to test command
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_INIT_START // timeout, reinit DRAMC
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x20 // wait for TCMD command response, bit[5]
		beqz	t0, 888b
		nop

		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		DLY_CLK_CYCLE(1) // tMRD (2nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
		j 99f
		nop
3:
		// DDR3
		DLY_CLK_CYCLE(2) // tMRD (4nCK by JEDEC spec, clock DRAMC:DRAM=1:2)
		
99:
		li		t0, 0x00000000 // clear NOP
		sw		t0, 0x1e4(k0)
		nop

		li		t0, 0x10622842 // disable R_DMMIOCKCTRLOFF for non-stop DRAM clock
		sw		t0, 0x1dc(k0)
		nop

		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2		
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0xf0740642 // enable R_DMCKEON for DDR2 //CML_20130307, for support list
		j 88f
		nop	
1:
		li		t0, 0xf00406a2 // enable R_DMCKEON for DDR2 FPGA //CML_20130104, for DDR2 performance
88:
		j 99f
		nop
3:
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0xf0740662 // enable R_DMCKEON for DDR3-800
		j 88f
		nop
1:				
		li		t0, 0xf07486e2 // enable R_DMCKEON for DDR3 FPGA
88:
99:

		// judge DRAM type & size to decide column address bit number
		li		t1, 0xfffffcff
		and		t0,	t0, t1 // clear column address width
		
		li		t1, DDR3
		beq		s1, t1, 10f	//	DDR3 type, all DDR3 column address width is 10 bit
		nop
		li		t1, DDR2
		bne		s1, t1, 9f	//	not DDR2 & DDR3 type, set column address width as 9 bit
		nop
		li		t1,	DRAM_SIZE_64MB
		bltu	s2, t1, 9f	// DDR2 type, size < 64 MB, set column address width as 9 bit; else 10 bit
		nop
10:
		ori		t0, 0x00000200 // 10-bit
		j			66f
		nop
9:
		ori		t0, 0x00000100 // 9-bit
66:
		sw		t0, 0x4(k0)
		nop
		
		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		
		// do nothing for DDR2
	
		j 99f
		nop
3:
		// DDR3
		li		t0, 0xa18711dd // set FREQDIV2, WTLAT, DATLAT, AC timing, ODT/OCD control, enable ODT after DRAM initial for DDR3-800
		sw		t0, 0x7c(k0)
		nop

99:

		/* *** set others *** */
		DLY_CLK_CYCLE(REG_RW_DELAY)
		
		li		t0, 0x00000000 // set CS delay
		sw		t0, 0xc(k0)
		nop
		
		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		li		t0, 0x22174441 // set AC timing, optimize timing for DDR2 //CML_20130307, for support list
		sw		t0, 0x0(k0)
		nop
		
		DLY_CLK_CYCLE(REG_RW_DELAY)
		
		// judge DRAM size to decide tRFC
		li		t1,	DRAM_SIZE_16MB
		bne	s2, t1, 111f
		nop
		li		t0, 0xa8040481 // set tRFC, optimize timing for DDR2
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000600 // set AC timing, optimize tRFC for DDR2
		sw		t0, 0x1e8(k0)
		nop
		j 222f
		nop
111:
		li		t1,	DRAM_SIZE_32MB
		bne	s2, t1, 111f
		nop
		li		t0, 0xa8040481 // set tRFC, optimize timing for DDR2
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000600 // set AC timing, optimize tRFC for DDR2
		sw		t0, 0x1e8(k0)
		nop
		j 222f
		nop
111:
		li		t1,	DRAM_SIZE_64MB
		bne	s2, t1, 111f
		nop
		li		t0, 0xa80a0481 // set tRFC, optimize timing for DDR2
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000600 // set AC timing, optimize tRFC for DDR2
		sw		t0, 0x1e8(k0)
		nop
		j 222f
		nop
111:
		li		t1,	DRAM_SIZE_128MB
		bne	s2, t1, 111f
		nop
		li		t0, 0xa80f0481 // set tRFC, optimize timing for DDR2
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000600 // set AC timing, optimize tRFC for DDR2
		sw		t0, 0x1e8(k0)
		nop
		j 222f
		nop
111:
		// no match size, might be error
		li		t0, 0xa8000481 // set tRFC, optimize timing for DDR2
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000650 // set AC timing, optimize tRFC for DDR2
		sw		t0, 0x1e8(k0)
		nop
222:
	#ifdef TCSUPPORT_DMT_CO
		li		t0, 0x000f5f18 // set REFCNT for DDR2-400
	#else
		li		t0, 0x000f5f2f // set REFCNT for DDR2-800
	#endif
		sw		t0, 0x8(k0)
		nop
		
		j 88f
		nop	
1:
		li		t0, 0x00074400 // set AC timing for DDR2 FPGA //CML_20130104, for DDR2 performance
		sw		t0, 0x0(k0)
		nop
		
		DLY_CLK_CYCLE(REG_RW_DELAY)
		
		li		t0, 0xa8000401 // set tRFC for DDR2 FPGA //CML_20130121, for improving performance
		sw		t0, 0x44(k0)
		nop
		
		li		t0, 0x00000600 // set AC timing for DDR2 FPGA //CML_20130121, change tRFC for improving performance
		sw		t0, 0x1e8(k0)
		nop
		
		li		t0, 0x0040430f // set REFCNT for DDR2 FPGA //CML_20130104, for DDR2 performance
		sw		t0, 0x8(k0)
		nop
88:
		
		j 99f
		nop
3:
		// DDR3
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		
		li		t0, 0x22274430 // set AC timing for DDR3-800
		sw		t0, 0x0(k0)
		nop
		DLY_CLK_CYCLE(REG_RW_DELAY)
		
		// judge DRAM size to decide tRFC
		li		t1,	DRAM_SIZE_64MB
		bne	s2, t1, 111f
		nop
		li		t0, 0xa88c0481 // set tRFC for DDR3
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000600 // set AC timing for DDR3
		sw		t0, 0x1e8(k0)
		nop
		j 222f
		nop
111:
		li		t1,	DRAM_SIZE_128MB
		bne	s2, t1, 111f
		nop
		li		t0, 0xa8810481 // set tRFC for DDR3
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000610 // set AC timing for DDR3
		sw		t0, 0x1e8(k0)
		nop
		j 222f
		nop
111:
		li		t1,	DRAM_SIZE_256MB
		bne	s2, t1, 111f
		nop
		li		t0, 0xa88d0481 // set tRFC for DDR3
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000610 // set AC timing for DDR3
		sw		t0, 0x1e8(k0)
		nop
		j 222f
		nop
111:
		li		t1,	DRAM_SIZE_512MB
		bne	s2, t1, 111f
		nop
		li		t0, 0xa8860481 // set tRFC for DDR3
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000630 // set AC timing for DDR3
		sw		t0, 0x1e8(k0)
		nop
		j 222f
		nop
111:
		// no match size, might be error
		li		t0, 0xa88d0481 // set tRFC for DDR3
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000660 // set AC timing for DDR3
		sw		t0, 0x1e8(k0)
		nop
222:

		li		t0, 0x000f5f2f // set REFCNT for DDR3-800
		sw		t0, 0x8(k0)
		nop
		
		j 88f
		nop
1:
		li		t0, 0x44ea45b9 // set AC timing for DDR3
		sw		t0, 0x0(k0)
		nop
		DLY_CLK_CYCLE(REG_RW_DELAY)
		li		t0, 0xa8800401 // set tRFC for DDR3 //CML_20130121, for improving performance
		sw		t0, 0x44(k0)
		nop
		li		t0, 0x00000600 // set AC timing for DDR3 //CML_20130121, change tRFC for improving performance
		sw		t0, 0x1e8(k0)
		nop
		li		t0, 0x00046907 // set REFCNT for DDR3
		sw		t0, 0x8(k0)
		nop
88:
99:

		li		t0, 0xedcb000f // set DRAM pin output enable
		sw		t0, 0xf8(k0)
		nop
		li		t0, 0x07010000 // set tXP //CML_20130307, for support list
		sw		t0, 0xfc(k0)
		nop
		
		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		
		li		t0, 0x00c80008 // set bus monitor for DDR2
		sw		t0, 0x1d8(k0)
		nop
		
		//for DDR2-800
		lw		t0, 0xe0(k0)
		li		t1, 0xf8ffffff
		and		t0,	t0, t1
		li		t1, 0x02000000
		or		t0, t0, t1
		sw		t0, 0xe0(k0)
		
		lw		t0, 0x124(k0)
		li		t1, 0xffffffcc
		and		t0,	t0, t1
		li		t1, 0x00000000
		or		t0, t0, t1
		sw		t0, 0x124(k0)
		
		li		t0, 0x30303030
		sw		t0, 0x94(k0)
		
		li		t0, 0x00001919
		sw		t0, 0x18(k0)
		li		t0, 0x05050505
		sw		t0, 0x210(k0)
		li		t0, 0x00000000
		sw		t0, 0x214(k0)
		li		t0, 0x06060606
		sw		t0, 0x218(k0)
		li		t0, 0x03030303
		sw		t0, 0x21c(k0)
		
		lw		t0, 0x7c(k0)
		li		t1, 0xffffff8f
		and		t0,	t0, t1
		li		t1, 0x00000040
		or		t0, t0, t1
		sw		t0, 0x7c(k0)
		
		lw		t0, 0xe4(k0)
		li		t1, 0xffffffef
		and		t0,	t0, t1
		sw		t0, 0xe4(k0)
		
		li		t0, 0x00000011
		sw		t0, 0x10(k0)
		li		t0, 0x11113333
		sw		t0, 0x200(k0)
		li		t0, 0x11112222
		sw		t0, 0x204(k0)
		li		t0, 0x00000023
		sw		t0, 0x14(k0)
		
		j 88f
		nop	
1:
		li		t0, 0x00c8000c
		sw		t0, 0x1d8(k0)
		nop
88:

		j 99f
		nop
3:
		li		t0, 0x00c80008 // set bus monitor for DDR3
		sw		t0, 0x1d8(k0)
		nop
		
		//for DDR3-800
		lw		t0, 0xe0(k0)
		li		t1, 0xf8ffffff
		and		t0,	t0, t1
		li		t1, 0x02000000
		or		t0, t0, t1
		sw		t0, 0xe0(k0)
		
		lw		t0, 0x124(k0)
		li		t1, 0xffffffcc
		and		t0,	t0, t1
		li		t1, 0x00000022
		or		t0, t0, t1
		sw		t0, 0x124(k0)
		
		li		t0, 0x30303030
		sw		t0, 0x94(k0)
		
		li		t0, 0x00001919
		sw		t0, 0x18(k0)
		li		t0, 0x06060606
		sw		t0, 0x210(k0)
		li		t0, 0x04040404
		sw		t0, 0x214(k0)
		li		t0, 0x09090909
		sw		t0, 0x218(k0)
		li		t0, 0x07070707
		sw		t0, 0x21c(k0)
		
		lw		t0, 0x7c(k0)
		li		t1, 0xffffff8f
		and		t0,	t0, t1
		li		t1, 0x00000050
		or		t0, t0, t1
		sw		t0, 0x7c(k0)

		lw		t0, 0xe4(k0)
		li		t1, 0xffffffef
		and		t0,	t0, t1
		sw		t0, 0xe4(k0)
		
		li		t0, 0x00000012
		sw		t0, 0x10(k0)
		li		t0, 0x11113333
		sw		t0, 0x200(k0)
		li		t0, 0x11112222
		sw		t0, 0x204(k0)
		li		t0, 0x00000023
		sw		t0, 0x14(k0)
		
99:

		
		/* *** set DRAM page size and enable DRAM controller *** */
		la		k0,	CR_ARB_BASE
		lw		t0, 0x74(k0)
		nop
		li		t1, 0xfffffef8
		and		t0, t0, t1 // 0x74[9:8]: DRAMC sel cmd pipeline; 0x74[2]: DRAMC enable; 0x74[1:0] : page size
		
		li		t1, DDR3
		beq		s1, t1, 2f	//	DDR3 type, all DDR3 page size is 2KB
		nop
		li		t1, DDR2
		bne		s1, t1, 1f	//	not DDR2 & DDR3 type, set page size as 1KB
		nop
		li		t1, DRAM_SIZE_32MB
		bgtu	s2, t1, 2f	// DDR2 type, size > 32 MB,  set page size as 2KB; else 1KB
		nop
1:
		ori		t0, 0x00000104 // page size 1KB and enable DRAMC(0x74[2]=1), use read cmd pipeline (0x74[9:8]=2'h1)
		j			55f
		nop
2:
		ori		t0, 0x00000105 // page size 2KB and enable DRAMC(0x74[2]=1), use read cmd pipeline (0x74[9:8]=2'h1)
55:
		sw		t0, 0x74(k0)
		nop
		DLY_CLK_CYCLE(150)
		
		
mtk_dmc_done:
		jr		DLY_RA
		nop

END(sys_init_mtk_dmc)

/************************************************************************
 *
 *                          sys_mtk_dmc_change_freq
 *  Description :
 *  -------------
 *  Perform MTK DMC change frequency procedure
 *
 *  Parameters :
 *  ------------
 *
 *  Return values :
 *  ---------------
 *  0 If OK, error code != 1 if error
  ************************************************************************/
LEAF(sys_mtk_dmc_change_freq)
		move DLY_RA, ra
		
MTK_DMC_CHANGE_FREQ_START:
		// judge the platform, DRAM type & size
		la		k0, CR_ARB_BASE
		lw		t0, 0x8c(k0)
		nop
		srl		s0, t0, 31 // FPGA indication

		// judge FPGA or ASIC platform
		bnez	s0, 1f // FPGA
		nop
		//ASIC
		srl		s1, t0, 18
		andi	s1, s1, 0x1	// DRAM type
		j 88f
		nop	
1:  //FPGA
		srl		s1, t0, 24
		andi	s1, s1, 0x3	// DRAM type
88:
		srl		s2, t0, 13
		andi	s2, s2, 0x7	// DRAM size
		
		srl		XTAL_SRC_SEL, t0, 22
		andi	XTAL_SRC_SEL, XTAL_SRC_SEL, 0x3	// Xtal Freq.

		li		CLK_CYCLE_NS, 1 // store the time per clock cycle in s7, unit: nano second, for ASIC 750MHz clock

		// FPGA platform
		bnez	s0, mtk_dmc_change_freq_done // FPGA doesn't need to change frequency
		nop
		
		/* *** disable DRAM controller *** */
		la		k0,	CR_ARB_BASE
		lw		t0, 0x74(k0)
		nop
		li		t1, 0xfffffffb
		and		t0, t0, t1 // 0x74[2]: DRAMC enable
		sw		t0, 0x74(k0)
		nop
		DLY_CLK_CYCLE(150)
		
		
		la		k0, CR_DMC_BASE // k0 stores DRAMC base address
		nop
		/* *** start changing frequency *** */

		lw		t0, 0xe4(k0)
		nop
		li		t1, 0xfffffffb
		and		t0,	t0, t1 // disable CKEFIXON
		sw		t0, 0xe4(k0)
		nop
		
		lw		t0, 0x4(k0)
		nop
		li		t1, 0x04000000
		or		t0,	t0, t1 // enter self-refresh
		sw		t0, 0x4(k0)
		nop
			
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_CHANGE_FREQ_START // timeout
		nop
		lw		t0, 0x3b8(k0)
		nop
		srl		t0, t0, 16 // SREF_STATE
		andi	t0, t0, 0x1 // wait for entering self refresh
		beqz	t0, 888b
		nop
		
		
		#ifdef MEMPLL1_CONFIG_FOR_SSC
		lw		t0, 0x60c(k0)
		li		t1, 0x00000001
		or		t0,	t0, t1
		sw		t0, 0x60c(k0)
		
		lw		t0, 0x600(k0)
		li		t1, 0xfffffffc
		and		t0,	t0, t1
		sw		t0, 0x600(k0)

		li		t0, 0x1e000000
		sw		t0, 0x608(k0)
		nop
		
		lw		t0, 0x60c(k0)
		li		t1, 0xffffefff
		and		t0,	t0, t1
		sw		t0, 0x60c(k0)
		
		lw		t0, 0x60c(k0)
		li		t1, 0x00001000
		or		t0,	t0, t1
		sw		t0, 0x60c(k0)

		lw		t0, 0x60c(k0)
		li		t1, 0xffffffef
		and		t0,	t0, t1
		sw		t0, 0x60c(k0)
		
		lw		t0, 0x600(k0)
		li		t1, 0xfffffff3
		and		t0,	t0, t1
		sw		t0, 0x600(k0)

		lw		t0, 0x600(k0)
		li		t1, 0x08000000
		or		t0,	t0, t1
		sw		t0, 0x600(k0)

		lw		t0, 0x61c(k0)
		li		t1, 0xffffffe0
		and		t0,	t0, t1
		li		t1, 0x0000000f
		or		t0, t0, t1
		sw		t0, 0x61c(k0)

		lw		t0, 0x618(k0)
		li		t1, 0x3fffffff
		and		t0,	t0, t1
		sw		t0, 0x618(k0)

		lw		t0, 0x604(k0)
		li		t1, 0xfffffff1
		and		t0,	t0, t1
		sw		t0, 0x604(k0)

		lw		t0, 0x604(k0)
		li		t1, 0xfffffffe
		and		t0,	t0, t1
		li		t1, 0x00000001
		or		t0, t0, t1
		sw		t0, 0x604(k0)

		lw		t0, 0x60c(k0)
		li		t1, 0xff7fffff
		and		t0,	t0, t1
		li		t1, 0x00800000
		or		t0, t0, t1
		sw		t0, 0x60c(k0)

		lw		t0, 0x610(k0)
		li		t1, 0xffff0000
		and		t0,	t0, t1
		li		t1, 0x000000fa
		or		t0, t0, t1
		sw		t0, 0x610(k0)

		lw		t0, 0x614(k0)
		li		t1, 0xfffffff0
		and		t0,	t0, t1
		sw		t0, 0x614(k0)

		lw		t0, 0x610(k0)
		li		t1, 0x000fffff
		and		t0,	t0, t1
		li		t1, 0x13a00000
		or		t0, t0, t1
		sw		t0, 0x610(k0)

		lw		t0, 0x614(k0)
		li		t1, 0xff0000ff
		and		t0,	t0, t1
		li		t1, 0x00013a00
		or		t0, t0, t1
		sw		t0, 0x614(k0)
		#endif //end of MEMPLL1_CONFIG_FOR_SSC
		
		li		t0, 0x02210a00 // reset RG_MEMPLL2_EN
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x02210a00 // reset RG_MEMPLL3_EN
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x02210a00 // reset RG_MEMPLL4_EN
		sw		t0, 0x644(k0)
		nop
		
		la		DLY_NS,	1000  // wait 1us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x0000000f // reset RG_MEMPLL_DIV_EN
		sw		t0, 0x61c(k0)
		nop
		
		la		DLY_NS,	20000  // wait 20us
		bal		dly_ns_mt75xx
		nop
		
		#ifdef MEMPLL1_CONFIG_FOR_SSC
		li		t0, 0x3a213c00 // reset RG_MEMPLL_EN
		sw		t0, 0x600(k0)
		nop
		
		la		DLY_NS,	1000000  // wait 1ms
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x1a003c00 // reset RG_MEMPLL_BIAS_LPF_EN
		sw		t0, 0x600(k0)
		nop
		
		la		DLY_NS,	2000  // wait 2us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x0a003c00 // set RG_MEMPLL_BIAS_EN
		sw		t0, 0x600(k0)
		nop

		la		DLY_NS,	2000  // wait 2us
		bal		dly_ns_mt75xx
		nop
				
		li		t0, 0x1a003c00 // set RG_MEMPLL_BIAS_EN
		sw		t0, 0x600(k0)
		nop
		
		la		DLY_NS,	2000  // wait 2us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x3a003c00 // set RG_MEMPLL_BIAS_LPF_EN
		sw		t0, 0x600(k0)
		nop

		la		DLY_NS,	1000000  // wait 1ms
		bal		dly_ns_mt75xx
		nop

		li		t0, 0x3a213c10 // set RG_MEMPLL_EN
		sw		t0, 0x600(k0)
		nop
		
		#else
		
		li		t0, 0x32213c00 // reset RG_MEMPLL_EN
		sw		t0, 0x600(k0)
		nop
		
		la		DLY_NS,	1000000  // wait 1ms
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x12003c00 // reset RG_MEMPLL_BIAS_LPF_EN
		sw		t0, 0x600(k0)
		nop
		
		la		DLY_NS,	2000  // wait 2us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x02003c00 // set RG_MEMPLL_BIAS_EN
		sw		t0, 0x600(k0)
		nop
		
		la		DLY_NS,	2000  // wait 2us
		bal		dly_ns_mt75xx
		nop
				
		li		t0, 0x12003c00 // set RG_MEMPLL_BIAS_EN
		sw		t0, 0x600(k0)
		nop
		
		la		DLY_NS,	2000  // wait 2us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x32003c00 // set RG_MEMPLL_BIAS_LPF_EN
		sw		t0, 0x600(k0)
		nop
		
		la		DLY_NS,	1000000  // wait 1ms
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x32213c10 // set RG_MEMPLL_EN
		sw		t0, 0x600(k0)
		nop
		#endif //end of MEMPLL1_CONFIG_FOR_SSC

		
		la		DLY_NS,	20000  // wait 20us
		bal		dly_ns_mt75xx
		nop
		
		li		t0, 0x0000002f // set RG_MEMPLL_DIV_EN
		sw		t0, 0x61c(k0)
		nop
		
		la		DLY_NS,	1000  // wait 1us
		bal		dly_ns_mt75xx
		nop
		
		// judge Xtal input frequence
		li		t0, XTAL_INPUT_FREQ_25MHZ
		beq		XTAL_SRC_SEL, t0, 25f	// Xtal input frequency 25 MHz
		nop
		
		// Xtal input frequency other than 25 MHz
		// DDR-800
		li		t0, 0x02211400 // set RG_MEMPLL2_FBKDIV
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x02211400 // set RG_MEMPLL3_FBKDIV
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x02211400 // set RG_MEMPLL4_FBKDIV
		sw		t0, 0x644(k0)
		nop
				
		li		t0, 0x00020000 // set RG_MEMPLL2_M4PDIV
		sw		t0, 0x624(k0)
		nop
		li		t0, 0x02211410 // set RG_MEMPLL2_EN
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL3_M4PDIV
		sw		t0, 0x630(k0)
		nop
		li		t0, 0x02211410 // set RG_MEMPLL3_EN
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL4_M4PDIV
		sw		t0, 0x648(k0)
		nop
		li		t0, 0x02211410 // set RG_MEMPLL4_EN
		sw		t0, 0x644(k0)
		nop
	
		j 333f
		nop
25:
		// Xtal input frequency 25 MHz
		// DDR-800
		li		t0, 0x02210800 // set RG_MEMPLL2_FBKDIV
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x02210800 // set RG_MEMPLL3_FBKDIV
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x02210800 // set RG_MEMPLL4_FBKDIV
		sw		t0, 0x644(k0)
		nop
		
		li		t0, 0x00020000 // set RG_MEMPLL2_M4PDIV
		sw		t0, 0x624(k0)
		nop
		li		t0, 0x02210810 // set RG_MEMPLL2_EN
		sw		t0, 0x620(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL3_M4PDIV
		sw		t0, 0x630(k0)
		nop
		li		t0, 0x02210810 // set RG_MEMPLL3_EN
		sw		t0, 0x62c(k0)
		nop
		li		t0, 0x00020000 // set RG_MEMPLL4_M4PDIV
		sw		t0, 0x648(k0)
		nop
		li		t0, 0x02210810 // set RG_MEMPLL4_EN
		sw		t0, 0x644(k0)
		nop

333:
	
		la		DLY_NS,	20000  // wait 20us
		bal		dly_ns_mt75xx
		nop
		
		lw		t0, 0x4(k0)
		nop
		li		t1, 0xfbffffff
		and		t0,	t0, t1 // eixt self-refresh
		sw		t0, 0x4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_CHANGE_FREQ_START // timeout
		nop
		lw		t0, 0x3b8(k0)
		nop
		srl		t0, t0, 16 // SREF_STATE
		andi	t0, t0, 0x1
		bnez	t0, 888b // wait for exiting self refresh
		nop
		
		lw		t0, 0xe4(k0)
		nop
		li		t1, 0x00000004
		or		t0,	t0, t1 // enable CKEFIXON
		sw		t0, 0xe4(k0)
		nop
		

		// judge DDR2 or DDR3
		li		t0, DDR3
		beq		s1, t0, 3f	// DDR3 type
		nop
		
		// DDR2
		li		t0, 0x000f5f2f // set REFCNT for DDR2-800
		sw		t0, 0x8(k0)
		nop
		
		//for DDR2-800
		lw		t0, 0xe0(k0)
		li		t1, 0xf8ffffff
		and		t0,	t0, t1
		li		t1, 0x02000000
		or		t0, t0, t1
		sw		t0, 0xe0(k0)
		
		lw		t0, 0x124(k0)
		li		t1, 0xffffffcc
		and		t0,	t0, t1
		li		t1, 0x00000000
		or		t0, t0, t1
		sw		t0, 0x124(k0)
		
		li		t0, 0x30303030
		sw		t0, 0x94(k0)
		
		li		t0, 0x00001919
		sw		t0, 0x18(k0)
		li		t0, 0x05050505
		sw		t0, 0x210(k0)
		li		t0, 0x00000000
		sw		t0, 0x214(k0)
		li		t0, 0x06060606
		sw		t0, 0x218(k0)
		li		t0, 0x03030303
		sw		t0, 0x21c(k0)
		
		lw		t0, 0x7c(k0)
		li		t1, 0xffffff8f
		and		t0,	t0, t1
		li		t1, 0x00000040
		or		t0, t0, t1
		sw		t0, 0x7c(k0)
		
		lw		t0, 0xe4(k0)
		li		t1, 0xffffffef
		and		t0,	t0, t1
		sw		t0, 0xe4(k0)
		
		li		t0, 0x00000011
		sw		t0, 0x10(k0)
		li		t0, 0x11113333
		sw		t0, 0x200(k0)
		li		t0, 0x11112222
		sw		t0, 0x204(k0)
		li		t0, 0x00000023
		sw		t0, 0x14(k0)
		
		j			99f
		nop
3:
		lw		t0, 0x7c(k0)
		nop
		li		t1, 0xfffffff7
		and		t0,	t0, t1 // disable ODT when MR setting
		sw		t0, 0x7c(k0)
		nop
		
		li		t0, 0x00002004 // set MR1, enable DLL, RTT = RZQ/4 for DDR3
		sw		t0, 0x88(k0)
		nop
		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_CHANGE_FREQ_START // timeout
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop
		
		DLY_CLK_CYCLE(2) // tMRD (4nCK by JEDEC spec, clock DRAMC:DRAM=1:2)

		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		li		t0, 0x00004200 // set MR2, RTT=ZQ/4, CWL=5 for DDR3 DDR3-800
		sw		t0, 0x88(k0)
		nop
		li		t0, 0x00000001 // enable MRW
		sw		t0, 0x1e4(k0)
		nop
		
		li		t1, DRAMC_WAIT_CMD_RESPONSE_MAX_CNT
888:
		subu	t1, t1, 0x1
		beqz	t1, MTK_DMC_CHANGE_FREQ_START // timeout
		nop
		lw		t0, 0x3b8(k0)
		nop
		andi	t0, t0, 0x1 // wait for MRW command response, bit[0]
		beqz	t0, 888b
		nop
		
		DLY_CLK_CYCLE(6) // tMOD (12nCK by JEDEC spec, clock DRAMC:DRAM=1:2)

		li		t0, 0x00000000 // disable MRW
		sw		t0, 0x1e4(k0)
		nop

		lw		t0, 0x1e0(k0)
		nop
		li		t1, 0x04000000
		or		t0,	t0, t1 // enable FASTOE for CWL < 6
		sw		t0, 0x1e0(k0)
		nop
		
		lw		t0, 0x7c(k0)
		nop
		li		t1, 0x8fffffff
		and		t0,	t0, t1 // clear WLAT setting
		li		t1, 0x20000008 // set WLAT = 2 for CWL=5 and enable ODT when MR setting finished
		or		t0, t0, t1
		sw		t0, 0x7c(k0)
		nop

		li		t0, 0x000f5f2f // set REFCNT for DDR3-800
		sw		t0, 0x8(k0)
		nop

		//for DDR3-800
		lw		t0, 0xe0(k0)
		li		t1, 0xf8ffffff
		and		t0,	t0, t1
		li		t1, 0x02000000
		or		t0, t0, t1
		sw		t0, 0xe0(k0)
		
		lw		t0, 0x124(k0)
		li		t1, 0xffffffcc
		and		t0,	t0, t1
		li		t1, 0x00000022
		or		t0, t0, t1
		sw		t0, 0x124(k0)
		
		li		t0, 0x30303030
		sw		t0, 0x94(k0)
		
		li		t0, 0x00001919
		sw		t0, 0x18(k0)
		li		t0, 0x06060606
		sw		t0, 0x210(k0)
		li		t0, 0x04040404
		sw		t0, 0x214(k0)
		li		t0, 0x09090909
		sw		t0, 0x218(k0)
		li		t0, 0x07070707
		sw		t0, 0x21c(k0)
		
		lw		t0, 0x7c(k0)
		li		t1, 0xffffff8f
		and		t0,	t0, t1
		li		t1, 0x00000050
		or		t0, t0, t1
		sw		t0, 0x7c(k0)
		
		lw		t0, 0xe4(k0)
		li		t1, 0xffffffef
		and		t0,	t0, t1
		sw		t0, 0xe4(k0)
		
		li		t0, 0x00000012
		sw		t0, 0x10(k0)
		li		t0, 0x11113333
		sw		t0, 0x200(k0)
		li		t0, 0x11112222
		sw		t0, 0x204(k0)
		li		t0, 0x00000023
		sw		t0, 0x14(k0)
		
99:

		/* *** set DRAM page size and enable DRAM controller *** */
		la		k0,	CR_ARB_BASE
		lw		t0, 0x74(k0)
		nop
		li		t1, 0x00000004
		or		t0, t0, t1 // 0x74[2]: DRAMC enable
		sw		t0, 0x74(k0)
		nop
		
		DLY_CLK_CYCLE(150)
		
mtk_dmc_change_freq_done:
		jr		DLY_RA
		nop
END(sys_mtk_dmc_change_freq)

/************************************************************************
 *
 *                          dly_ns_mt75xx
 *  Description :
 *  -------------
 *  Perform nano second delay for MT75xx 
 *
 *  Parameters :
 *  ------------
 *
 *  Return values :
 *  ---------------
 *  
 *
 ************************************************************************/
LEAF(dly_ns_mt75xx)
		//move	t0, DLY_NS
		
		#if 0	
		div	DLY_NS, CLK_CYCLE_NS
		mflo t0
		srl	t0, t0, 1
		#else
		srl	t0, DLY_NS, 10
		#endif
		
999:	subu	t0, t0, 1
		bgtz	t0, 999b
		nop

		jr		ra
		nop
END(dly_ns_mt75xx)





#ifdef SIS_DDR_PHY
#ifndef MT75XX_REDUCE_SIZE

/************************************************************************
 *
 *                          sys_init_ddr
 *  Description :
 *  -------------
 *  Perform DDR PHY initialization
 *
 *  Parameters :
 *  ------------
 *
 *  Return values :
 *  ---------------
 *  0 If OK, error code != 1 if error
 *
 ************************************************************************/
LEAF(sys_init_ddr)

		/* de-assert R_DQSDLL_RSTN */
		li		v1, CR_DMC_BASE		
		lw		t0, 0x110(v1)	
		nop
		li		t1, (1<<27)
		or		t0, t0, t1
		sw		t0, 0x110(v1)	
		nop

		/* Enable CK output */
		lw		t0, 0x108(v1)	
		nop
		li		t1, (1<<25)
		or		t0, t0, t1
		sw		t0, 0x108(v1)	
		nop

		/* Enable DQS input delay (DQS DLL) initialization */
		/* Enable DQ output driving calibration */
		/* Enable EDQS window calibration */
		/* Enable DQ input duty calibration */

		/* Enable CMD output */
		lw		t0, 0x108(v1)	
		nop
		li		t1, (1<<29)
		or		t0, t0, t1
		sw		t0, 0x108(v1)	
		nop

		/* wait 200us for 50Mhz */ 
		li		t0,	5000
1:                              		
		subu	t0,	0x01
		bnez	t0,	1b
		nop

		/* Enable DDR controller */
		lw		t0, 0x120(v1)	
		nop
		li		t1, (1<<2)
		or		t0, t0, t1
		sw		t0, 0x120(v1)	
		nop

		/* RDPOP delay=3 and enable dynamic input buffer */
		lw		t0, 0x120(v1)	
		nop
		li		t1, ~(0x7<<8)
		and		t0, t0, t1
		li		t1, (0x3<<8)
		or		t0, t0, t1
		/*
		li		t1, (0x1<<3)
		or		t0, t0, t1
		*/
		sw		t0, 0x120(v1)	
		nop

		/* DQS INDLY=8 */
		lw		t0, 0x110(v1)	
		nop
		ori		t0, t0, (0x8<<6)
		sw		t0, 0x110(v1)	
		nop

		jr		ra
		nop

END(sys_init_ddr)

/************************************************************************
 *
 *                          sys_edqs_scan
 *  Description :
 *  -------------
 *  Perform simple memory test
 *
 *  Parameters :
 *  ------------
 *  a0 = RAM start address
 *  a1 = RAM size
 *
 *  Return values :
 *  ---------------
 *  0 If OK, error code != 1 if error
 *
 ************************************************************************/
LEAF(sys_edqs_scan)

#define ADDR     		t0
#define LAST     		t1
#define DATA     		t2

#define MIN_VALID     	t3
#define MAX_FAIL     	t4
#define OFFSET	     	t5
#define OFFSET_MAX     	t6
#define OFFSET_MIN     	t7

#define RD_DQS_WIN_DLY1	s0
#define EDQS_PHASE		s1
#define EDQS_DLY		s2
#define RDPOP_DLY		s3
#define RDRDY_DLY		s4

#define W_R_MATCH		s5
#define CL_FACTOR  		s6

		move	v0, zero

		li		v1, CR_DMC_BASE		

edqs_scan_init:
		move	MIN_VALID, zero
		move	MAX_FAIL, zero
		move	OFFSET, zero
		move	OFFSET_MAX, zero
		move	OFFSET_MIN, zero

edqs_scan_loop:
		/* edqs_dly       = edqs_offset & 0x00000007; */
		andi	EDQS_DLY, OFFSET, 0x7
		/* edqs_phase     = (edqs_offset & 0x00000018) >> 3; */
		andi	EDQS_PHASE, OFFSET, 0x18
		srl		EDQS_PHASE, EDQS_PHASE, 3
		/* rd_dqs_win_dly = (edqs_offset & 0x000000e0) >> 5; */
		andi	RD_DQS_WIN_DLY1, OFFSET, 0xe0
		srl		RD_DQS_WIN_DLY1, RD_DQS_WIN_DLY1, 5

		/* VPint(0xbfb20108) = (VPint(0xbfb20108) & 0xfff1fcff) | (edqs_dly << 17) | (edqs_phase << 8); */
		lw 		t8, 0x108(v1)
		li		t9, 0xfff1fcff
		and		t8, t8, t9
		sll		t9, EDQS_DLY, 17
		or		t8, t8, t9
		sll		t9, EDQS_PHASE, 8
		or		t8, t8, t9
		sw 		t8, 0x108(v1)
		nop

		/* VPint(0xbfb20120) = (VPint(0xbfb20120) & 0xfff8ffff) | (rd_dqs_win_dly1 << 16); */
		lw 		t8, 0x120(v1)
		nop
		/* rdpop_dly = (VPint(0xbfb20120) & 0x00000700) >> 8; */
		andi	RDPOP_DLY, t8, 0x700
		srl		RDPOP_DLY, RDPOP_DLY, 8
		li		t9, 0xfff8ffff
		and		t8, t8, t9
		sll 	t9, RD_DQS_WIN_DLY1, 16
		or		t8, t8, t9
		sw 		t8, 0x120(v1)
		nop

		move 	RDRDY_DLY, zero
		move	W_R_MATCH, zero

edqs_mem_test:
		/* VPint(0xbfb20120) = (VPint(0xbfb20120) & 0xffff8fff) | (rdrdy_dly << 12); */
		lw 		t8, 0x120(v1)
		nop
		li		t9, 0xffff8fff
		and		t8, t8, t9
		sll 	t9, RDRDY_DLY, 12
		or		t8, t8, t9
		sw 		t8, 0x120(v1)
		nop
		
		/* Memory test */
		addu	LAST, a0, a1
		addiu	LAST, -4

		/* Write */
		la		k0, pattern
		move	ADDR, a0
		sll		DATA, OFFSET, 2
		andi	DATA, DATA, 0x3f
1:
		add		t9, DATA, k0
		lw		t9, 0(t9)
		nop
		sw		t9, 0(ADDR)
		addiu	DATA, 4
		andi	DATA, DATA, 0x3f
		bne		ADDR, LAST, 1b
		addiu	ADDR, 4

		/* dcache write-back invalidate */
		move	ADDR, a0
1:
SET_MIPS3()
		cache   DCACHE_ADDR_HIT_WRITEBACK_INVALIDATE, 0(ADDR)
		sync
SET_MIPS0()
		addiu 	ADDR, ADDR, 32
		bgeu	LAST, ADDR, 1b
		nop

		/* Read */
		la		k0, pattern
		move	ADDR, a0
		sll		DATA, OFFSET, 2
		andi	DATA, DATA, 0x3f
1:
		add		t9, DATA, k0
		lw		t9, 0(t9)
		lw		t8, 0(ADDR)
		nop
		bne		t8, t9, 1f
		addiu	DATA, 4
		andi	DATA, DATA, 0x3f
		bne		ADDR, LAST, 1b
		addiu	ADDR, 4

		/* No error */
		ori		W_R_MATCH, W_R_MATCH, 1	
		b		2f
		nop
1:	
		/**** DONE ****/
    	li   	t8, 7
    	beq  	RDRDY_DLY, t8, 2f
    	nop
    	addi 	RDRDY_DLY, 0x1
 
    	j    	edqs_mem_test
    	nop

2:
		/* if (edqs_min_valid == 0) */
		bnez   	MIN_VALID, edqs_min_valid_not_zero
		nop
		/* 		if (w_r_match) */
		beqz   	W_R_MATCH, edqs_max_fail_not_zero
		nop
		/* 			edqs_min_valid = 1; */
		ori		MIN_VALID, MIN_VALID, 1
		/* 			edqs_offset_min = edqs_offset; */
		move	OFFSET_MIN, OFFSET
		j 		edqs_max_fail_not_zero
		nop

		/* else if (edqs_max_fail == 0) */
edqs_min_valid_not_zero:
		bnez   	MAX_FAIL, edqs_max_fail_not_zero
		nop
		/* 		if (w_r_match) */
		beqz   	W_R_MATCH, 1f
		nop
		/* 			edqs_offset_max = edqs_offset; */
		move	OFFSET_MAX, OFFSET
		j		edqs_max_fail_not_zero
		nop
1:
		/* 			edqs_max_fail = 1; */
		ori		MAX_FAIL, MAX_FAIL, 1

edqs_max_fail_not_zero:
		/* if (edqs_offset == 223) */
		li		t8, 223
		bne		OFFSET, t8, 1f
		nop
		bnez	MAX_FAIL, edqs_scan_done
		nop
		/* edqs_offset_max = edqs_offset; */
		move	OFFSET_MAX, OFFSET;
		j		edqs_scan_done
		nop

1:
		/* edqs_offset++; */
		addiu   OFFSET, OFFSET, 1	

		/* while ((edqs_min_valid == 0) || (edqs_max_fail == 0)) */
		beqz   	MIN_VALID, edqs_scan_loop
		nop
		beqz   	MAX_FAIL, edqs_scan_loop
		nop

edqs_scan_done:		
		/* edqs_offset    = (edqs_offset_max + edqs_offset_min) / 2; */
		addu	OFFSET, OFFSET_MAX, OFFSET_MIN
		srl		OFFSET, OFFSET, 1
		/* edqs_dly       = edqs_offset & 0x00000007; */
		andi	EDQS_DLY, OFFSET, 0x7
		/* edqs_phase     = (edqs_offset & 0x00000018) >> 3; */
		andi	EDQS_PHASE, OFFSET, 0x18
		srl		EDQS_PHASE, EDQS_PHASE, 3
		/* rd_dqs_win_dly = (edqs_offset & 0x000000e0) >> 5; */
		andi	RD_DQS_WIN_DLY1, OFFSET, 0xe0
		srl		RD_DQS_WIN_DLY1, RD_DQS_WIN_DLY1, 5

		/* VPint(0xbfb20108) = (VPint(0xbfb20108) & 0xfff1fcff) | (edqs_dly << 17) | (edqs_phase << 8); */
		lw 		t8, 0x108(v1)
		li		t9, 0xfff1fcff
		and		t8, t8, t9
		sll		t9, EDQS_DLY, 17
		or		t8, t8, t9
		sll		t9, EDQS_PHASE, 8
		or		t8, t8, t9
		sw 		t8, 0x108(v1)
		nop

		/* VPint(0xbfb20120) = (VPint(0xbfb20120) & 0xfff8ffff) | (rd_dqs_win_dly1 << 16); */
		lw 		t8, 0x120(v1)
		nop
		/* rdpop_dly = (VPint(0xbfb20120) & 0x00000700) >> 8; */
		andi	RDPOP_DLY, t8, 0x700
		srl		RDPOP_DLY, RDPOP_DLY, 8
		li		t9, 0xfff8ffff
		and		t8, t8, t9
		sll 	t9, RD_DQS_WIN_DLY1, 16
		or		t8, t8, t9
		sw 		t8, 0x120(v1)
		nop

		move 	RDRDY_DLY, zero

edqs_mem_test2:
		/* VPint(0xbfb20120) = (VPint(0xbfb20120) & 0xffff8fff) | (rdrdy_dly << 12); */
		lw 		t8, 0x120(v1)
		nop
		li		t9, 0xffff8fff
		and		t8, t8, t9
		sll 	t9, RDRDY_DLY, 12
		or		t8, t8, t9
		sw 		t8, 0x120(v1)
		nop
		
		/* Memory test */
		addu	LAST, a0, a1
		addiu	LAST, -4

		/* Write */
		la		k0, pattern
		move	ADDR, a0
		sll		DATA, OFFSET, 2
		andi	DATA, DATA, 0x3f
1:
		add		t9, DATA, k0
		lw		t9, 0(t9)
		nop
		sw		t9, 0(ADDR)
		addiu	DATA, 4
		andi	DATA, DATA, 0x3f
		bne		ADDR, LAST, 1b
		addiu	ADDR, 4

		/* dcache write-back invalidate */
		move	ADDR, a0
1:
SET_MIPS3()
		cache   DCACHE_ADDR_HIT_WRITEBACK_INVALIDATE, 0(ADDR)
		sync
SET_MIPS0()
		addiu 	ADDR, ADDR, 32
		bgeu	LAST, ADDR, 1b
		nop

		/* Read */
		la		k0, pattern
		move	ADDR, a0
		sll		DATA, OFFSET, 2
		andi	DATA, DATA, 0x3f
1:
		add		t9, DATA, k0
		lw		t9, 0(t9)
		lw		t8, 0(ADDR)
		nop
		bne		t8, t9, 1f
		addiu	DATA, 4
		andi	DATA, DATA, 0x3f
		bne		ADDR, LAST, 1b
		addiu	ADDR, 4

		/* No error */
		b		edqs_scan_exit
		nop
1:	
		/**** DONE ****/
    	li   	t8, 7
		/* When edqs scan fail, restart to reboot and do edqs again. */
    	beq  	RDRDY_DLY, t8, __start
/*    	beq  	RDRDY_DLY, t8, edqs_scan_exit */
    	nop
    	addi 	RDRDY_DLY, 0x1
 
    	j    	edqs_mem_test2
    	nop

edqs_scan_exit:		
		/* save EDQS min/max and result */
		li		v1, 0x80020000		
		sw		OFFSET_MIN, -4(v1)
		sw		OFFSET_MAX, -8(v1)
		sw		OFFSET, -12(v1)
		nop

		jr		ra
		nop

pattern:
		.word	0x5A5A5A5A, 0xA5A5A5A5, 0x5555AAAA, 0xAAAA5555
		.word	0xF0F0F0F0, 0x0F0F0F0F, 0x00FF00FF, 0xFF00FF00
		.word	0x12345678, 0x87654321, 0x11223344, 0x55667788
		.word	0x01020304, 0x05060708, 0x09101112, 0x13141516

END(sys_edqs_scan)
#endif

#else

/************************************************************************
 *
 *                          sys_pll_scan
 *  Description :
 *  -------------
 *  Perform simple memory test
 *
 *  Parameters :
 *  ------------
 *  a0 = RAM start address
 *  a1 = RAM size
 *
 *  Return values :
 *  ---------------
 *  0 If OK, error code != 1 if error
 *
 ************************************************************************/
LEAF(sys_pll_scan)

#define MAGIC_DATA1	0xA5A5A5A5
#define MAGIC_DATA2	0x5A5A5A5A

#define ADDR     t0
#define LAST     t1
#define DATA     t2

		move	v0, zero

		move	t4, zero
pll_scan_loop:

		li		v1, CR_DMC_BASE		
		ori     t5, t4, 0x100
		sw		t5, 0xb0(v1)	
		nop

1:
		lw		t5, 0xb0(v1)
		and		t5, t5, 0x8000
		bnez    t5, 1b
		nop
		
		addu	LAST, a0, a1
		addiu	LAST, -4

		/* Write */
		move	ADDR, a0
#if 1
		move	DATA, t4
#else
		andi 	v1, t4, 0x1
		beqz	v1, 2f
		nop
		li		DATA, MAGIC_DATA2
		b		1f
		nop
2:
		li		DATA, MAGIC_DATA1
#endif
1:
		sw	DATA, 0(ADDR)
#if 1
		addiu	DATA, 1
#endif
		bne		ADDR, LAST, 1b
		addiu	ADDR, 4

		/* Read */
		move	ADDR, a0
#if 1
		move	DATA, t4
#else
		andi 	v1, t4, 0x1
		beqz	v1, 2f
		nop
		li		DATA, MAGIC_DATA2
		b		1f
		nop
2:
		li		DATA, MAGIC_DATA1
#endif
1:
		lw		t3, 0(ADDR)
		bne		t3, DATA, 1f
#if 1
		addiu	DATA, 1
#else
		nop
#endif
		bne		ADDR, LAST, 1b
		addiu	ADDR, 4

		/* No error */
		li		v1, 1
		sllv    v1, v1, t4
		or      v0, v0, v1
1:	
		/**** DONE ****/
		addiu   t4, t4, 1	
		slti    v1, t4, 32
		bnez    v1, pll_scan_loop
		nop

pll_scan_done:		
		jr	ra
		nop

END(sys_pll_scan)

/************************************************************************
 *
 *                          sys_pll_choose
 *  Description :
 *  -------------
 *  Perform simple memory test
 *
 *  Parameters :
 *  ------------
 *  a0 = possible PLL bitmap
 *
 *  Return values :
 *  ---------------
 *  0 If OK, error code != 1 if error
 *
 ************************************************************************/
LEAF(sys_pll_choose)

#define LOW      t0
#define HIGH     t1
#define MAXBITS  t2
#define BITS	 t3
#define PLLVAL	 t4

		li		v0, 32
		move	MAXBITS, zero
		move	PLLVAL, zero

pll_choose_loop:

1:
		beqz	v0, 1f
		nop
		addiu   v0, v0, -1
		li		v1, 1
		sllv	v1, v1, v0
		and		v1, a0, v1
		beqz	v1, 1b
		nop

1:
		move	HIGH, v0

2:
		beqz	v0, 2f
		nop
		addiu   v0, v0, -1
		li		v1, 1
		sllv	v1, v1, v0
		and		v1, a0, v1
		bnez	v1, 2b
		nop

2:
		move	LOW, v0
3:
		subu	BITS, HIGH, LOW
		slt		v1, MAXBITS, BITS
		beqz	v1, 3f
		nop

		move 	MAXBITS, BITS
		addu	v1, HIGH, LOW
		addiu	v1, v1, 1
		sra		PLLVAL, v1, 0x1
3:
		bnez    v0, pll_choose_loop
		nop

pll_choose_done:		
		move 	v0, PLLVAL
		jr		ra
		nop
END(sys_pll_choose)

#endif

#ifdef MT7510_DCACHE_TEST
#define R_C0_DataLo	      	28
#define R_C0_SelDataLo	    1

#define R_C0_TagLo			28
#define R_C0_SelTagLo		0


#define DCT_STARTADDR	0x80020000 	/* dcache test start addr */
#define DCT_SIZE			0x10000		/* dcache test size: 64KB */
#define DCT_LINESIZE		0x20		/* dcache test line size: 32B */

#if 1
//==============================================================							 			
// DCacheTag_test
//==============================================================
/* 	test dcache tag array. 
	1. round-1:	
	  - write all tag array to 0xFFFFFCE0
	  - read value from dcache tag array and compare with 0xFFFFFCE0 (skip R, P bits)
	  - if any not match, then fail; 
	  - else continue round-2
	2. round-2: 
	  - write all tag array to 0x0
	  - read value from dcache tag array and compare with 0x0
	  - if any not match, then fail; 
	  - else pass
*/
LEAF(DCacheTag_test)
			.set  noreorder

			li	t0, 	0x2 //round
			li 	t1, 	0xFFFFFCE0	/*value write to tags, skip R, P bits */
			li 	t2,	0x0			/* values read from taglo, use it to compare with t1 */
			li  	v0, 1			/* init return value fail */
			
			/* write patterns to tag array */
dct_test_start:
			MTC0_SEL_OPCODE( R_t1, R_C0_TagLo, R_C0_SelTagLo )
			/* Calc an address that will correspond to the first cache line */
			li    a2, DCT_STARTADDR
								
			/* Calc an address that will correspond to the last cache line */
			addu  a3, a2, DCT_SIZE
			//subu  a3, a3, DCT_LINESIZE
															
			/* Loop through all lines, set each tag to 0 */
1:
			cache DCACHE_INDEX_STORE_TAG, 0(a2)
			addu  a2, a2, DCT_LINESIZE
			bne   a2, a3, 1b
			nop			

			/* check the whole d-cache tag array*/
			/* Calc an address that will correspond to the first cache line */
			li    a2, DCT_STARTADDR
								
			/* Calc an address that will correspond to the last cache line */
			addu  a3, a2, DCT_SIZE
			//subu  a3, a3, DCT_LINESIZE
			
1:			/* Loop through all lines, invalidating each of them */
			cache DCACHE_INDEX_LOAD_TAG, 0(a2)
			/* check tag array */
			//mfc0 t0, 	R_C0_TagLo, R_C0_SelTagLo
			li	t2, 0x0
			MFC0_SEL_OPCODE( R_t2, R_C0_TagLo, R_C0_SelTagLo )
			bne	  t2, t1, dct_test_fail /* if (t1!=t2) goto fail */
			nop
			addu  a2, a2, DCT_LINESIZE	
			bne   a2, a3, 1b
			nop

			li 	t1, 0x0 /* set round-2 t1 to 0 */
			subu		t0,	t0, 	1 /* round--*/
			bnez		t0, 	dct_test_start	 	
			nop
		
dct_test_pass:
			li 	v0, 0
			j	dct_test_done
			nop
dct_test_fail:
			li v0, 1
dct_test_done:
			jr    ra
			nop

			.set  reorder
END(DCacheTag_test)
#endif

#if 1
//==============================================================							 			
// DCacheData_test
//==============================================================
/* 	test dcache data array. 
	1. write 16KB uncached SDRAM to 0
	2. valide all cache line mapping to the whole 16KB SDRAM 
	3. write all 16KB cached SDRAM to 0xFFFFFFFF (NOTE: new data should only keep in cache)
	4. read all data from uncached SDRAM and compared with 0xFFFFFFFF, if mach, then fail, else pass
*/
LEAF(DCacheData_test)
			.set  noreorder
#define RA              		t4
			move RA, ra

			li  	v0, 1			/* init return value fail */

			/* init all 16KB SDRAM to 0*/
			li	a2, 	DCT_STARTADDR
			li 	t0, 	0xA0000000
			or 	a2, 	a2, 	t0		/*change to uncached address */
			addu  a3, a2, DCT_SIZE
1:
			sw zero, (a2)
			addu a2, a2, 4
			bne   a2, a3, 1b
			nop				

			li    	a2, 	DCT_STARTADDR		
			addu  a3, a2, DCT_SIZE
			li 	t0, 	0xFFFFFC00
1:			/* valide all cache line mapping to the SDRAM */
			and 	t1, 	a2, 	t0 /* move PA to t1 */
			ori 	t1, 	t1,	0x80		/* valide PA */
			MTC0_SEL_OPCODE( R_t1, R_C0_TagLo, R_C0_SelTagLo )
			cache DCACHE_INDEX_STORE_TAG, 0(a2)
			addu  a2, a2, DCT_LINESIZE
			bne   a2, a3, 1b
			nop		

			li    	a2, 	DCT_STARTADDR
			addu  a3, a2, DCT_SIZE
			li 	t1, 	0xFFFFFFFF			
1:			/* write all 16KB cache to 0xFFFFFFFF */
			sw 	t1, 	(a2)
			addu a2, 	a2, 	4
			bne   a2, 	a3, 	1b
			nop

			/* read all data from uncached sdram and compared with 0xFFFFFFFF, if mach, then fail*/
			li	a2, 	DCT_STARTADDR
			li 	t0, 	0xA0000000
			or 	a2, 	a2, 	t0		/*change to uncached address */
			addu  a3, a2, DCT_SIZE
			li 	t1, 	0xFFFFFFFF
1:
			lw	t2, 	(a2)
			nop
			beq	t2, 	t1, 	dcd_test_fail /* if (t1==t2) goto fail */
			nop				
			addu a2, a2, 4
			bne   a2, a3, 1b
			nop

			/*write back the cache data*/
			/*DCACHE_ADDR_HIT_WRITEBACK*/
			li    	a2, 	DCT_STARTADDR		
			addu  a3, a2, DCT_SIZE			
1:			/* write back all cache line to the SDRAM */
			cache DCACHE_ADDR_HIT_WRITEBACK, 0(a2)
			addu  a2, a2, DCT_LINESIZE
			bne   a2, a3, 1b
			nop

			/* read all data from uncached sdram and compared with 0xFFFFFFFF, if not mach, then fail*/
			li	a2, 	DCT_STARTADDR
			li 	t0, 	0xA0000000
			or 	a2, 	a2, 	t0		/*change to uncached address */
			addu  a3, a2, DCT_SIZE
			li 	t1, 	0xFFFFFFFF
1:
			lw	t2, 	(a2)
			nop
			bne	t2, 	t1, 	dcd_test_fail /* if (t1==t2) goto fail */
			nop				
			addu a2, a2, 4
			bne   a2, a3, 1b
			nop

			/* init all 64KB uncache SDRAM to 0 again*/
			li	a2, 	DCT_STARTADDR
			li 	t0, 	0xA0000000
			or 	a2, 	a2, 	t0		/*change to uncached address */
			addu  a3, a2, DCT_SIZE
1:
			sw zero, (a2)
			addu a2, a2, 4
			bne   a2, a3, 1b
			nop

			/*invalide the cache data*/
			/*DCACHE_ADDR_HIT_INVALIDATE*/
			li    	a2, 	DCT_STARTADDR		
			addu  a3, a2, DCT_SIZE			
1:			/* invalide the cache data*/
			cache DCACHE_ADDR_HIT_INVALIDATE, 0(a2)
			addu  a2, a2, DCT_LINESIZE
			bne   a2, a3, 1b
			nop

			/* read all data from uncached sdram and compared with 0x0, if not mach, then fail*/
			li	a2, 	DCT_STARTADDR
			li 	t0, 	0xA0000000
			or 	a2, 	a2, 	t0		/*change to uncached address */
			addu  a3, a2, DCT_SIZE
			li 	t1, 	0x0
1:
			lw	t2, 	(a2)
			nop
			bne	t2, 	t1, 	dcd_test_fail /* if (t1==t2) goto fail */
			nop				
			addu a2, a2, 4
			bne   a2, a3, 1b
			nop
			

dcd_test_pass:
			li 	v0, 0
			j	dcd_test_done
			nop
dcd_test_fail:
			li v0, 1
dcd_test_done:
			//jr    ra
			jr RA
			nop

			.set  reorder
END(DCacheData_test)
#endif

/*************************
 * GPIO Module Registers *
 *************************/
#define CR_GPIO_BASE       	0xBFBF0200
#define CR_GPIO_CTRL	    (CR_GPIO_BASE + 0x00)
#define CR_GPIO_DATA	    (CR_GPIO_BASE + 0x04)
#define CR_GPIO_INTS      	(CR_GPIO_BASE + 0x08)
#define CR_GPIO_EDET	    (CR_GPIO_BASE + 0x0C)
#define CR_GPIO_LDET       	(CR_GPIO_BASE + 0x10)
#define CR_GPIO_ODRAIN      (CR_GPIO_BASE + 0x14)
#define CR_GPIO_CTRL1	    (CR_GPIO_BASE + 0x20)

LEAF(turnon_gpio)
		/*configure gpio as ouput*/
		bgt	a0, 15, 2f
		nop
		la      t0, CR_GPIO_CTRL
		b	3f
		nop

2:
		la      t0, CR_GPIO_CTRL1
3:
		lw      t1, 0x0(t0)
		nop
		sll	t2, a0, 1
		li	t3, 1
		sll	t2, t3, t2
		or	t1, t1, t2
		sw	t1, 0x0(t0)
		nop

		/*set it as open drain*/
		la      t0, CR_GPIO_ODRAIN
		lw      t1, 0x0(t0)
		nop
		li  t2, 1
		sll	t2, t2, a0
		or	t1, t1, t2
		sw	t1, 0x0(t0)
		nop

		/*set output high/low*/
		la      t0, CR_GPIO_DATA
		lw      t1, 0x0(t0)
		nop

		li 	t2, 1
		sll	t2, t2, a0

		beq		a1, 1,  set_high
		nop
		
		/*output is low*/
		not	t2, t2		
		and	t1, t1, t2
		b	1f
		nop

set_high:
		/*output is high*/
		or	t1, t1, t2

1:
		sw	t1, 0x0(t0)
		nop

		jr	ra
		nop


END(turnon_gpio)


#endif /* MT7510_CACHE_TEST */

#endif
#ifdef DEBUG
LEAF(sys_uart_init)
            la          k0,     0xbfbf0000

//              DISPLAYLED(0xf7, 0x10000)

                /*
                        VPchar(CR_UART_LCR)=UART_BRD_ACCESS;
                */
                li              k1, 0x80
                sb              k1, 0x0f(k0)


//              DISPLAYLED(0xdf, 0x10000)

                /*
                        VPint(CR_UART_XYD)=word;
                */
                la              k1, 0xea00fde8
                sw              k1, 0x2c(k0)
                nop


//              DISPLAYLED(0xfd, 0x10000)

                /*
                        VPchar(CR_UART_BRDL)=UART_BRDL;
                */
                li              k1, 0x01
                sb              k1, 0x03(k0)


//              DISPLAYLED(0xbf, 0x10000)

                /*
                        VPchar(CR_UART_BRDH)=UART_BRDH;
                */
                li              k1, 0x00
                sb              k1, 0x07(k0)

//              DISPLAYLED(0x7f, 0x10000)

                /*
                        VPchar(CR_UART_LCR)=UART_LCR;
                */
                li              k1, 0x03
                sb              k1, 0x0f(k0)


//              DISPLAYLED(0xff, 0x10000)

                /*
                        VPchar(CR_UART_FCR)=UART_FCR|UART_WATERMARK;
                */
                li              k1, 0x0f
                sb              k1, 0x0b(k0)

//              DISPLAYLED(0x00, 0x10000)

                /*
                        VPchar(CR_UART_MCR)=UART_MCR;
                */                                                              
                li              k1, 0x00
                sb              k1, 0x13(k0)

//              DISPLAYLED(0xf7, 0x10000)

                /*
                        VPchar(CR_UART_MISCC)=UART_MISCC;
                */                                                              
                li              k1, 0x00
                sb              k1, 0x27(k0)

//              DISPLAYLED(0xdf, 0x10000)

                /*
                        VPchar(CR_UART_IER)=UART_IER;
                */                                                              
                li              k1, 0x01
                sb              k1, 0x07(k0)

//              DISPLAYLED(0xfd, 0x10000)

                /*
                        VPint(CR_INTC_IMR)|= (0x01 << intSource);
                        UART_INT
                */
                la              t0, 0xbfb40000
                li              k1, 0x01
                sb              k1, 0x04(t0)
#if 1
                /*
                        test code
                */
                li              k1, 'h'
                sb              k1, 0x03(k0)
1:
                lb      t5, 0x17(k0)
                nop
                andi    t5, 0x20
                beqz     t5, 1b
                nop


                li              k1, 'e'
                sb              k1, 0x03(k0)
                //jal           check_uart_status
                //nop

2:
                lb    t5, 0x17(k0)
                nop
                andi    t5, 0x20
                beqz    t5, 2b
                nop


                li              k1, 'l'
                sb              k1, 0x03(k0)
                //jal           check_uart_status
                //nop
3:
                lb    t5, 0x17(k0)
                nop
                andi    t5, 0x20
                beqz    t5, 3b
                nop



                li              k1, 'l'
                sb              k1, 0x03(k0)
                //jal           check_uart_status
                //nop
4:
                lb      t5, 0x17(k0)
                nop
                andi    t5, 0x20
                beqz    t5, 4b
                nop

                li              k1, 'o'
                sb              k1, 0x03(k0)
                //jal           check_uart_status
                //nop
5:
                lb    t5, 0x17(k0)
                nop
                andi    t5, 0x20
                beqz    t5, 5b
                nop
#endif
//              DISPLAYLED(0xbf, 0x10000)

                jr    ra
                nop

END(sys_uart_init)

LEAF(disp_character)
                la              k0,     0xbfbf0000
wait:
                lb              t5, 0x17(k0)
                nop
                andi            t5, 0x20
                beqz    t5, wait
                nop

                sb              t7, 0x03(k0)

                jr    ra
                nop
END(disp_character)
#endif
